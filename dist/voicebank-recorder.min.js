/*!
 * voicebank-recorder v1.0.0
 * 跨平台音訊錄音庫，支援 Browser/Electron/Capacitor
 * 
 * @license MIT
 * @author VoiceBank Team
 * @repository https://github.com/cychiang-ntpu/simple-recordrtc-example.git
 */
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).VoiceBankRecorder={})}(this,function(e){"use strict";class t{async save(e,t,r={}){throw new Error("save() must be implemented by subclass")}async load(e){throw new Error("load() must be implemented by subclass")}async delete(e){throw new Error("delete() must be implemented by subclass")}async list(){throw new Error("list() must be implemented by subclass")}async exists(e){try{return await this.load(e),!0}catch(e){return!1}}async clear(){const e=await this.list();let t=0;for(const r of e)try{await this.delete(r.id||r.filename),t++}catch(e){console.error("Failed to delete file:",r,e)}return t}}class r{constructor(e={}){this.options=this.mergeOptions(e),this.initialized=!1,this.storage=this.createStorageAdapter(this.options.storage),this.isRecording=!1,this.isPaused=!1,this.currentBlob=null,this.options.container&&this.initializeUI()}mergeOptions(e){const t={container:null,layout:"auto",theme:"light",audio:{sampleRate:48e3,channels:1,agc:!1,gain:1},waveform:{showOverview:!0,showAccumulated:!0,showLive:!0,decimation:10,colors:{waveform:"#1E88E5",selection:"#4CAF50",playback:"#FF0000"}},storage:{type:"auto"},callbacks:{onRecordStart:()=>{},onRecordStop:()=>{},onRecordPause:()=>{},onRecordResume:()=>{},onPlayStart:()=>{},onPlayStop:()=>{},onError:e=>console.error("VoiceBankRecorder error:",e)}};return this.deepMerge(t,e)}deepMerge(e,t){const r={...e};for(const e in t)t[e]instanceof Object&&!Array.isArray(t[e])?r[e]=this.deepMerge(r[e]||{},t[e]):r[e]=t[e];return r}createStorageAdapter(e){const{StorageFactory:t}=require("./storage/index.js");return t.create({type:e.type||"auto",options:e})}initializeUI(){console.log("UI initialization - to be implemented")}async startRecording(){try{if(this.isRecording)throw new Error("Already recording");this.isRecording=!0,this.options.callbacks.onRecordStart(),console.log("Recording started")}catch(e){throw this.options.callbacks.onError(e),e}}async stopRecording(){try{if(!this.isRecording)throw new Error("Not recording");return this.isRecording=!1,this.currentBlob=null,this.options.callbacks.onRecordStop(this.currentBlob),console.log("Recording stopped"),this.currentBlob}catch(e){throw this.options.callbacks.onError(e),e}}async pauseRecording(){try{if(!this.isRecording||this.isPaused)throw new Error("Cannot pause");this.isPaused=!0,this.options.callbacks.onRecordPause(),console.log("Recording paused")}catch(e){throw this.options.callbacks.onError(e),e}}async resumeRecording(){try{if(!this.isRecording||!this.isPaused)throw new Error("Cannot resume");this.isPaused=!1,this.options.callbacks.onRecordResume(),console.log("Recording resumed")}catch(e){throw this.options.callbacks.onError(e),e}}async play(){try{this.options.callbacks.onPlayStart(),console.log("Playback started")}catch(e){throw this.options.callbacks.onError(e),e}}async stop(){try{this.options.callbacks.onPlayStop(),console.log("Playback stopped")}catch(e){throw this.options.callbacks.onError(e),e}}async saveRecording(e=null,t=null,r={}){try{const o=e||this.currentBlob;if(!o)throw new Error("No recording to save");const i=t||`recording-${Date.now()}.wav`,s=await this.storage.save(o,i,r);return console.log("Recording saved:",s),s}catch(e){throw this.options.callbacks.onError(e),e}}async loadRecording(e){try{const t=await this.storage.load(e);return this.currentBlob=t,console.log("Recording loaded:",e),t}catch(e){throw this.options.callbacks.onError(e),e}}async deleteRecording(e){try{const t=await this.storage.delete(e);return console.log("Recording deleted:",e),t}catch(e){throw this.options.callbacks.onError(e),e}}async listRecordings(){try{const e=await this.storage.list();return console.log("Recordings listed:",e.length),e}catch(e){throw this.options.callbacks.onError(e),e}}getCurrentBlob(){return this.currentBlob}destroy(){this.isRecording=!1,this.isPaused=!1,this.currentBlob=null,this.storage&&"function"==typeof this.storage.close&&this.storage.close(),console.log("VoiceBankRecorder destroyed")}}const o="1.0.0",i={version:o,date:(new Date).toISOString(),name:"VoiceBank Recorder"};e.AudioEngine=class{constructor(e={}){this.config={sampleRate:e.sampleRate||48e3,autoGainControl:void 0!==e.autoGainControl&&e.autoGainControl,echoCancellation:void 0!==e.echoCancellation&&e.echoCancellation,noiseSuppression:void 0!==e.noiseSuppression&&e.noiseSuppression,micGain:e.micGain||1,deviceId:e.deviceId||null,workletPath:e.workletPath||"assets/js/worklet/pcm-collector.js",preferWorklet:void 0===e.preferWorklet||e.preferWorklet},this.audioContext=null,this.analyser=null,this.preGainNode=null,this.mediaDest=null,this.analyserSilencer=null,this.workletSupported=!1,this.workletLoaded=!1,this.pcmCollectorNode=null,this.usingWorklet=!1,this.pcmChunks=[],this.pcmTotalSamples=0,this.recorder=null,this.micStream=null,this.isRecording=!1,this.isPaused=!1,this.isInitialized=!1,this.recordStartTime=0,this.recordStopTime=0,this.recordWallStartMs=0,this.recordWallStopMs=0,this.latestBlob=null,this.latestUrl=null,this._eventListeners={}}async initialize(){if(!this.isInitialized)try{const e=window.AudioContext||window.webkitAudioContext;if(this.audioContext=new e({sampleRate:this.config.sampleRate}),this.analyser=this.audioContext.createAnalyser(),this.analyser.fftSize=256,this.preGainNode=this.audioContext.createGain(),this.preGainNode.gain.value=this.config.micGain,this.mediaDest=this.audioContext.createMediaStreamDestination(),this.preGainNode.connect(this.analyser),this.preGainNode.connect(this.mediaDest),this.analyserSilencer=this.audioContext.createGain(),this.analyserSilencer.gain.value=0,this.analyser.connect(this.analyserSilencer),this.analyserSilencer.connect(this.audioContext.destination),this.workletSupported=!(!this.audioContext.audioWorklet||!window.AudioWorkletNode),this.workletSupported&&this.config.preferWorklet)try{await this.audioContext.audioWorklet.addModule(this.config.workletPath),this.workletLoaded=!0,this._emit("worklet-loaded",{path:this.config.workletPath})}catch(e){console.warn("載入 AudioWorklet 模組失敗，將回退到 RecordRTC:",e),this.workletLoaded=!1,this._emit("worklet-load-failed",{error:e})}"suspended"===this.audioContext.state&&await this.audioContext.resume(),this.isInitialized=!0,this._emit("initialized",{sampleRate:this.audioContext.sampleRate,state:this.audioContext.state,workletSupported:this.workletSupported,workletLoaded:this.workletLoaded})}catch(e){throw this._emit("error",{stage:"initialize",error:e}),e}}async startRecording(){if(!this.isInitialized)throw new Error("AudioEngine 尚未初始化，請先調用 initialize()");if(this.isRecording)throw new Error("已經在錄音中");try{"suspended"===this.audioContext.state&&await this.audioContext.resume(),await this._captureMicrophone(),this.pcmChunks=[],this.pcmTotalSamples=0,this.latestUrl&&(URL.revokeObjectURL(this.latestUrl),this.latestUrl=null),this.latestBlob=null,this.recordStartTime=Date.now(),this.recordWallStartMs=performance.now(),this.recordStopTime=0,this.recordWallStopMs=0;const e=this.workletLoaded&&this.config.preferWorklet;e?await this._startWorkletRecording():await this._startRecordRTCRecording(),this.isRecording=!0,this.isPaused=!1,this._emit("recording-start",{timestamp:this.recordStartTime,mode:e?"worklet":"recordrtc",sampleRate:this.audioContext.sampleRate})}catch(e){throw this._emit("error",{stage:"start-recording",error:e}),e}}async stopRecording(){if(!this.isRecording)throw new Error("目前沒有在錄音");try{let e;if(this.isRecording=!1,this.recordStopTime=Date.now(),this.recordWallStopMs=performance.now(),this.usingWorklet)e=await this._stopWorkletRecording();else{if(!this.recorder)throw new Error("沒有可用的錄音器");e=await this._stopRecordRTCRecording()}this._stopMicrophone(),this.latestBlob=e,this.latestUrl=URL.createObjectURL(e);const t=(this.recordStopTime-this.recordStartTime)/1e3;return this._emit("recording-stop",{blob:e,url:this.latestUrl,duration:t,samples:this.pcmTotalSamples,sampleRate:this.audioContext.sampleRate}),e}catch(e){throw this._emit("error",{stage:"stop-recording",error:e}),e}}pauseRecording(){if(!this.isRecording)throw new Error("目前沒有在錄音");if(this.usingWorklet)throw new Error("AudioWorklet 模式不支援暫停功能");if(!this.recorder||"function"!=typeof this.recorder.pauseRecording)throw new Error("暫停功能不可用");this.recorder.pauseRecording(),this.isPaused=!0,this._emit("recording-paused",{timestamp:Date.now()})}resumeRecording(){if(!this.isPaused)throw new Error("錄音沒有暫停");if(!this.recorder||"function"!=typeof this.recorder.resumeRecording)throw new Error("繼續錄音功能不可用");this.recorder.resumeRecording(),this.isPaused=!1,this._emit("recording-resumed",{timestamp:Date.now()})}getLatestRecording(){return{blob:this.latestBlob,url:this.latestUrl,duration:this.latestBlob?(this.recordStopTime-this.recordStartTime)/1e3:0,samples:this.pcmTotalSamples,sampleRate:this.audioContext?this.audioContext.sampleRate:0}}getPcmWindow(e,t){if(!this.usingWorklet||!this.pcmChunks.length)return null;e<0&&(e=0);const r=this.pcmTotalSamples;if(e>=r)return new Float32Array(0);const o=Math.min(r,e+t),i=new Float32Array(o-e);let s=0,a=0;for(let t=0;t<this.pcmChunks.length&&a<o;t++){const r=this.pcmChunks[t];if(!r||!r.length)continue;const n=a,c=a+r.length;if(c<=e){a=c;continue}const l=Math.max(e,n),d=Math.min(o,c);if(d>l){const e=l-n,t=r.subarray(e,e+(d-l));i.set(t,s),s+=t.length}if(a=c,d>=o)break}return i}getAnalyser(){return this.analyser}getAudioContext(){return this.audioContext}setMicGain(e){e=Math.max(1,Math.min(6,e)),this.config.micGain=e,this.preGainNode&&(this.preGainNode.gain.value=e),this._emit("mic-gain-changed",{gain:e})}dispose(){this.isRecording&&this.stopRecording().catch(console.error),this._stopMicrophone(),this.latestUrl&&(URL.revokeObjectURL(this.latestUrl),this.latestUrl=null),this.audioContext&&(this.audioContext.close().catch(console.error),this.audioContext=null),this.analyser=null,this.preGainNode=null,this.mediaDest=null,this.analyserSilencer=null,this.pcmCollectorNode=null,this.recorder=null,this.pcmChunks=[],this.pcmTotalSamples=0,this.isInitialized=!1,this._emit("disposed")}on(e,t){this._eventListeners[e]||(this._eventListeners[e]=[]),this._eventListeners[e].push(t)}off(e,t){if(!this._eventListeners[e])return;const r=this._eventListeners[e].indexOf(t);r>-1&&this._eventListeners[e].splice(r,1)}_emit(e,t){this._eventListeners[e]&&this._eventListeners[e].forEach(r=>{try{r(t)}catch(t){console.error(`事件處理器錯誤 [${e}]:`,t)}})}async _captureMicrophone(){const e={audio:{echoCancellation:this.config.echoCancellation,noiseSuppression:this.config.noiseSuppression,autoGainControl:this.config.autoGainControl},video:!1};this.config.deviceId&&(e.audio.deviceId={exact:this.config.deviceId});try{this.micStream=await navigator.mediaDevices.getUserMedia(e),this._applyIOSMicGainAdjustment();this.audioContext.createMediaStreamSource(this.micStream).connect(this.preGainNode),this._emit("microphone-captured",{deviceId:this.config.deviceId,constraints:e})}catch(t){if("OverconstrainedError"!==t.name&&"NotFoundError"!==t.name)throw t;console.warn("指定的麥克風無法使用，嘗試預設設備"),delete e.audio.deviceId,this.micStream=await navigator.mediaDevices.getUserMedia(e),this._applyIOSMicGainAdjustment();this.audioContext.createMediaStreamSource(this.micStream).connect(this.preGainNode),this._emit("microphone-captured-fallback",{constraints:e})}}_stopMicrophone(){this.micStream&&(this.micStream.getTracks().forEach(e=>{try{e.stop()}catch(e){console.warn("停止麥克風軌道失敗:",e)}}),this.micStream=null)}_applyIOSMicGainAdjustment(){try{const e=navigator.userAgent||"";/iphone|ipad|ipod/i.test(e)&&!this.config.autoGainControl&&Math.abs(this.config.micGain-1)<1e-4&&(this.setMicGain(3.5),this._emit("ios-gain-adjusted",{gain:3.5}))}catch(e){console.warn("iOS 增益調整失敗:",e)}}async _startWorkletRecording(){try{this.pcmCollectorNode=new AudioWorkletNode(this.audioContext,"pcm-collector-processor"),this.pcmCollectorNode.port.onmessage=e=>{const{type:t,pcmData:r}=e.data;"pcm-data"===t&&r&&(this.pcmChunks.push(new Float32Array(r)),this.pcmTotalSamples+=r.length,this._emit("data-available",{pcmData:new Float32Array(r),totalSamples:this.pcmTotalSamples,mode:"worklet"}))},this.preGainNode.connect(this.pcmCollectorNode),this.pcmCollectorNode.connect(this.audioContext.destination),this.usingWorklet=!0}catch(e){console.error("AudioWorklet 啟動失敗，回退到 RecordRTC:",e),this.usingWorklet=!1,await this._startRecordRTCRecording()}}async _stopWorkletRecording(){try{if(this.pcmCollectorNode&&(this.pcmCollectorNode.port.onmessage=null,this.preGainNode.disconnect(this.pcmCollectorNode),this.pcmCollectorNode.disconnect(),this.pcmCollectorNode=null),0===this.pcmChunks.length)throw new Error("沒有錄音數據");const e=new Float32Array(this.pcmTotalSamples);let t=0;for(const r of this.pcmChunks)e.set(r,t),t+=r.length;const r=this._buildWavFromFloat32Mono(e,this.audioContext.sampleRate),o=new Blob([r],{type:"audio/wav"});return this.usingWorklet=!1,o}catch(e){throw console.error("AudioWorklet 停止失敗:",e),e}}async _startRecordRTCRecording(){return new Promise((e,t)=>{try{if("undefined"==typeof RecordRTC)return void t(new Error("RecordRTC 未載入"));const r=this.mediaDest.stream||this.micStream;this.recorder=RecordRTC(r,{type:"audio",mimeType:"audio/wav",recorderType:StereoAudioRecorder,numberOfAudioChannels:1,bufferSize:4096,timeSlice:100,ondataavailable:e=>{this._emit("data-available",{blob:e,mode:"recordrtc"})}}),this.recorder.startRecording(),this.usingWorklet=!1,e()}catch(e){t(e)}})}async _stopRecordRTCRecording(){return new Promise((e,t)=>{try{if(!this.recorder)return void t(new Error("RecordRTC 錄音器不存在"));this.recorder.stopRecording(()=>{try{const t=this.recorder.getBlob();this.recorder=null,e(t)}catch(e){t(e)}})}catch(e){t(e)}})}_buildWavFromFloat32Mono(e,t){const r=e.length,o=new ArrayBuffer(44+2*r),i=new DataView(o);this._writeString(i,0,"RIFF"),i.setUint32(4,36+2*r,!0),this._writeString(i,8,"WAVE"),this._writeString(i,12,"fmt "),i.setUint32(16,16,!0),i.setUint16(20,1,!0),i.setUint16(22,1,!0),i.setUint32(24,t,!0),i.setUint32(28,2*t,!0),i.setUint16(32,2,!0),i.setUint16(34,16,!0),this._writeString(i,36,"data"),i.setUint32(40,2*r,!0);let s=44;for(let t=0;t<r;t++){const r=Math.max(-1,Math.min(1,e[t])),o=r<0?32768*r:32767*r;i.setInt16(s,o,!0),s+=2}return o}_writeString(e,t,r){for(let o=0;o<r.length;o++)e.setUint8(t+o,r.charCodeAt(o))}},e.BUILD_INFO=i,e.CapacitorAdapter=class extends t{constructor(e="recordings"){if(super(),this.directory=e,"undefined"==typeof window||!window.Capacitor)throw new Error("Capacitor not available. Make sure Capacitor is properly initialized.");this.Capacitor=window.Capacitor,this.initialized=!1}async initialize(){if(!this.initialized)try{const{Filesystem:e,Directory:t}=this.Capacitor.Plugins;try{await e.readdir({path:this.directory,directory:t.Documents})}catch(r){await e.mkdir({path:this.directory,directory:t.Documents,recursive:!0})}this.initialized=!0}catch(e){throw console.error("Capacitor initialization error:",e),e}}async save(e,t,r={}){await this.initialize();try{const{Filesystem:o,Directory:i}=this.Capacitor.Plugins,s=await this.blobToBase64(e);if(await o.writeFile({path:`${this.directory}/${t}`,data:s,directory:i.Documents}),r&&Object.keys(r).length>0){const s={...r,size:e.size,type:e.type,timestamp:Date.now()};await o.writeFile({path:`${this.directory}/${t}.meta.json`,data:JSON.stringify(s),directory:i.Documents,encoding:"utf8"})}return t}catch(e){throw console.error("Capacitor save error:",e),e}}async load(e){await this.initialize();try{const{Filesystem:t,Directory:r}=this.Capacitor.Plugins,o=await t.readFile({path:`${this.directory}/${e}`,directory:r.Documents});return this.base64ToBlob(o.data,"audio/wav")}catch(e){throw console.error("Capacitor load error:",e),e}}async delete(e){await this.initialize();try{const{Filesystem:t,Directory:r}=this.Capacitor.Plugins;await t.deleteFile({path:`${this.directory}/${e}`,directory:r.Documents});try{await t.deleteFile({path:`${this.directory}/${e}.meta.json`,directory:r.Documents})}catch(e){}return!0}catch(e){throw console.error("Capacitor delete error:",e),e}}async list(){await this.initialize();try{const{Filesystem:e,Directory:t}=this.Capacitor.Plugins,r=(await e.readdir({path:this.directory,directory:t.Documents})).files.filter(e=>!e.endsWith(".meta.json")),o=await Promise.all(r.map(async r=>{let o={};try{const i=await e.readFile({path:`${this.directory}/${r}.meta.json`,directory:t.Documents,encoding:"utf8"});o=JSON.parse(i.data)}catch(e){}return{id:r,filename:r,metadata:o,timestamp:o.timestamp||0,date:o.timestamp?new Date(o.timestamp):null,size:o.size||0,type:o.type||"audio/wav"}}));return o.sort((e,t)=>t.timestamp-e.timestamp),o}catch(e){return console.error("Capacitor list error:",e),[]}}async getUri(e){await this.initialize();try{const{Filesystem:t,Directory:r}=this.Capacitor.Plugins;return(await t.getUri({path:`${this.directory}/${e}`,directory:r.Documents})).uri}catch(e){throw console.error("Capacitor getUri error:",e),e}}blobToBase64(e){return new Promise((t,r)=>{const o=new FileReader;o.onloadend=()=>{const e=o.result.split(",")[1];t(e)},o.onerror=r,o.readAsDataURL(e)})}base64ToBlob(e,t="audio/wav"){const r=atob(e),o=new Array(r.length);for(let e=0;e<r.length;e++)o[e]=r.charCodeAt(e);const i=new Uint8Array(o);return new Blob([i],{type:t})}async getStorageInfo(){const e=await this.list(),t=e.reduce((e,t)=>e+(t.size||0),0);return{count:e.length,totalSize:t,totalSizeMB:(t/1048576).toFixed(2),recordings:e}}},e.ElectronAdapter=class extends t{constructor(e="recordings"){if(super(),this.savePath=e,"undefined"==typeof window||!window.electronAPI)throw new Error("Electron API not available. Make sure preload script is properly configured.");this.electronAPI=window.electronAPI}async save(e,t,r={}){try{const o=await e.arrayBuffer(),i=Array.from(new Uint8Array(o)),s=await this.electronAPI.saveRecording({filename:t,buffer:i,metadata:{...r,size:e.size,type:e.type,timestamp:Date.now()}});if(s.success)return s.id||s.path;throw new Error(s.error||"Save failed")}catch(e){throw console.error("Electron save error:",e),e}}async load(e){try{const t=await this.electronAPI.loadRecording(e),r=new Uint8Array(t);return new Blob([r],{type:"audio/wav"})}catch(e){throw console.error("Electron load error:",e),e}}async delete(e){try{return(await this.electronAPI.deleteRecording(e)).success}catch(e){throw console.error("Electron delete error:",e),e}}async list(e=null){try{return await this.electronAPI.listRecordings(e)||[]}catch(e){return console.error("Electron list error:",e),[]}}async openFile(){try{if(this.electronAPI.openFile)return await this.electronAPI.openFile();throw new Error("openFile API not available")}catch(e){return console.error("Electron openFile error:",e),null}}async saveAs(e,t="recording.wav"){try{const r=await e.arrayBuffer(),o=Array.from(new Uint8Array(r));if(this.electronAPI.saveAs){const e=await this.electronAPI.saveAs({filename:t,buffer:o});return e.success?e.path:null}return await this.save(e,t)}catch(e){return console.error("Electron saveAs error:",e),null}}async showInFolder(e){try{return!!this.electronAPI.showInFolder&&(await this.electronAPI.showInFolder(e),!0)}catch(e){return console.error("Electron showInFolder error:",e),!1}}},e.IndexedDBAdapter=class extends t{constructor(e="VoiceBankDB",t="recordings",r=1){super(),this.dbName=e,this.storeName=t,this.version=r,this.db=null}async initialize(){return this.db?this.db:new Promise((e,t)=>{const r=indexedDB.open(this.dbName,this.version);r.onerror=()=>{t(new Error(`Failed to open IndexedDB: ${r.error}`))},r.onsuccess=()=>{this.db=r.result,e(this.db)},r.onupgradeneeded=e=>{const t=e.target.result;if(!t.objectStoreNames.contains(this.storeName)){const e=t.createObjectStore(this.storeName,{keyPath:"id",autoIncrement:!0});e.createIndex("filename","filename",{unique:!1}),e.createIndex("timestamp","timestamp",{unique:!1}),e.createIndex("duration","duration",{unique:!1})}}})}async save(e,t,r={}){return await this.initialize(),new Promise((o,i)=>{const s=this.db.transaction([this.storeName],"readwrite"),a=s.objectStore(this.storeName),n={filename:t,blob:e,size:e.size,type:e.type,timestamp:Date.now(),metadata:r},c=a.add(n);c.onsuccess=()=>{o(String(c.result))},c.onerror=()=>{i(new Error(`Failed to save recording: ${c.error}`))},s.onerror=()=>{i(new Error(`Transaction failed: ${s.error}`))}})}async load(e){return await this.initialize(),new Promise((t,r)=>{const o=this.db.transaction([this.storeName],"readonly").objectStore(this.storeName).get(Number(e));o.onsuccess=()=>{const i=o.result;i&&i.blob?t(i.blob):r(new Error(`Recording not found: ${e}`))},o.onerror=()=>{r(new Error(`Failed to load recording: ${o.error}`))}})}async delete(e){return await this.initialize(),new Promise((t,r)=>{const o=this.db.transaction([this.storeName],"readwrite").objectStore(this.storeName).delete(Number(e));o.onsuccess=()=>{t(!0)},o.onerror=()=>{r(new Error(`Failed to delete recording: ${o.error}`))}})}async list(){return await this.initialize(),new Promise((e,t)=>{const r=this.db.transaction([this.storeName],"readonly").objectStore(this.storeName).getAll();r.onsuccess=()=>{const t=r.result.map(e=>({id:String(e.id),filename:e.filename,size:e.size,type:e.type,timestamp:e.timestamp,date:new Date(e.timestamp),metadata:e.metadata||{}}));e(t)},r.onerror=()=>{t(new Error(`Failed to list recordings: ${r.error}`))}})}async searchByFilename(e){return(await this.list()).filter(t=>t.filename.toLowerCase().includes(e.toLowerCase()))}async getStorageInfo(){const e=await this.list(),t=e.reduce((e,t)=>e+t.size,0);return{count:e.length,totalSize:t,totalSizeMB:(t/1048576).toFixed(2),records:e}}async clear(){return await this.initialize(),new Promise((e,t)=>{const r=this.db.transaction([this.storeName],"readwrite").objectStore(this.storeName),o=r.count();o.onsuccess=()=>{const i=o.result,s=r.clear();s.onsuccess=()=>{e(i)},s.onerror=()=>{t(new Error(`Failed to clear recordings: ${s.error}`))}},o.onerror=()=>{t(new Error(`Failed to count recordings: ${o.error}`))}})}async getStorageEstimate(){if("storage"in navigator&&"estimate"in navigator.storage)try{const e=await navigator.storage.estimate();return{usage:e.usage,quota:e.quota,usageMB:(e.usage/1048576).toFixed(2),quotaMB:(e.quota/1048576).toFixed(2),usagePercent:(e.usage/e.quota*100).toFixed(2)}}catch(e){return console.warn("Failed to get storage estimate:",e),null}return null}close(){this.db&&(this.db.close(),this.db=null)}},e.PlatformDetector=class{static detect(){return"undefined"!=typeof window&&window.electronAPI||"undefined"!=typeof process&&process.versions&&process.versions.electron?"electron":"undefined"!=typeof window&&window.Capacitor?"capacitor":"browser"}static isElectron(){return"electron"===this.detect()}static isCapacitor(){return"capacitor"===this.detect()}static isBrowser(){return"browser"===this.detect()}static isMobile(){return!("undefined"==typeof window||!window.navigator)&&/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(window.navigator.userAgent)}static supportsAudioWorklet(){if("undefined"==typeof window||!window.AudioContext)return!1;return"audioWorklet"in(window.AudioContext||window.webkitAudioContext).prototype}static supportsOffscreenCanvas(){return"undefined"!=typeof OffscreenCanvas}static getInfo(){return{platform:this.detect(),isElectron:this.isElectron(),isCapacitor:this.isCapacitor(),isBrowser:this.isBrowser(),isMobile:this.isMobile(),supportsAudioWorklet:this.supportsAudioWorklet(),supportsOffscreenCanvas:this.supportsOffscreenCanvas(),userAgent:"undefined"!=typeof navigator?navigator.userAgent:"unknown"}}},e.ServerAdapter=class extends t{constructor(e={}){super(),this.baseURL=e.baseURL||"",this.saveEndpoint=e.saveEndpoint||"/backend/save.php",this.loadEndpoint=e.loadEndpoint||"/public/uploads/",this.deleteEndpoint=e.deleteEndpoint||"/backend/delete.php",this.listEndpoint=e.listEndpoint||"/api/recordings",this.headers=e.headers||{}}async save(e,t,r={}){const o=new FormData;o.append("audio-blob",e),o.append("audio-filename",t),r&&Object.keys(r).length>0&&o.append("metadata",JSON.stringify(r));try{const e=await fetch(this.baseURL+this.saveEndpoint,{method:"POST",body:o,headers:this.headers});if(!e.ok)throw new Error(`Upload failed: ${e.status} ${e.statusText}`);const r=await e.text();if(r.toLowerCase().includes("success"))return t;throw new Error(`Server error: ${r}`)}catch(e){throw console.error("Save error:",e),e}}async load(e){try{const t=this.baseURL+this.loadEndpoint+e,r=await fetch(t,{headers:this.headers});if(!r.ok)throw new Error(`Load failed: ${r.status} ${r.statusText}`);return await r.blob()}catch(e){throw console.error("Load error:",e),e}}async delete(e){try{const t=await fetch(this.baseURL+this.deleteEndpoint,{method:"POST",headers:{"Content-Type":"application/json",...this.headers},body:JSON.stringify({filename:e})});if(!t.ok)throw new Error(`Delete failed: ${t.status} ${t.statusText}`);return(await t.text()).toLowerCase().includes("success")}catch(e){throw console.error("Delete error:",e),e}}async list(){try{const e=await fetch(this.baseURL+this.listEndpoint,{headers:this.headers});if(!e.ok)throw new Error(`List failed: ${e.status} ${e.statusText}`);const t=await e.json();return Array.isArray(t)?t:[]}catch(e){return console.error("List error:",e),[]}}async saveWithProgress(e,t,r={},o=null){return new Promise((i,s)=>{const a=new FormData;a.append("audio-blob",e),a.append("audio-filename",t),r&&Object.keys(r).length>0&&a.append("metadata",JSON.stringify(r));const n=new XMLHttpRequest;o&&n.upload.addEventListener("progress",e=>{if(e.lengthComputable){const t=e.loaded/e.total*100;o(t)}}),n.addEventListener("load",()=>{if(n.status>=200&&n.status<300){const e=n.responseText;e.toLowerCase().includes("success")?i(t):s(new Error(`Server error: ${e}`))}else s(new Error(`Upload failed: ${n.status} ${n.statusText}`))}),n.addEventListener("error",()=>{s(new Error("Network error during upload"))}),n.addEventListener("abort",()=>{s(new Error("Upload cancelled"))}),n.open("POST",this.baseURL+this.saveEndpoint),Object.keys(this.headers).forEach(e=>{n.setRequestHeader(e,this.headers[e])}),n.send(a)})}},e.StorageAdapter=t,e.StorageFactory=class{static create(e={}){const t=e.type||"auto",r=e.options||{};if("auto"===t)return this.createAuto(r);switch(t.toLowerCase()){case"browser":case"indexeddb":const{IndexedDBAdapter:e}=require("./IndexedDBAdapter.js");return new e(r.dbName,r.storeName,r.version);case"electron":const{ElectronAdapter:o}=require("./ElectronAdapter.js");return new o(r.savePath);case"capacitor":const{CapacitorAdapter:i}=require("./CapacitorAdapter.js");return new i(r.directory);case"server":case"php":case"nodejs":const{ServerAdapter:s}=require("./ServerAdapter.js");return new s(r);default:throw new Error(`Unknown storage type: ${t}`)}}static createAuto(e={}){if("undefined"!=typeof window&&window.electronAPI){const{ElectronAdapter:t}=require("./ElectronAdapter.js");return new t(e.savePath)}if("undefined"!=typeof window&&window.Capacitor){const{CapacitorAdapter:t}=require("./CapacitorAdapter.js");return new t(e.directory)}const{IndexedDBAdapter:t}=require("./IndexedDBAdapter.js");return new t(e.dbName,e.storeName,e.version)}},e.VERSION=o,e.VoiceBankRecorder=r,e.default=r,Object.defineProperty(e,"__esModule",{value:!0})});
//# sourceMappingURL=voicebank-recorder.min.js.map
