{"version":3,"file":"voicebank-recorder.min.js","sources":["../src/storage/StorageAdapter.js","../src/index.js","../src/core/AudioEngine.js","../src/storage/CapacitorAdapter.js","../src/storage/ElectronAdapter.js","../src/storage/IndexedDBAdapter.js","../src/utils/PlatformDetector.js","../src/storage/ServerAdapter.js","../src/storage/index.js"],"sourcesContent":["/**\n * StorageAdapter - 儲存適配器基類\n * 定義統一的儲存介面，支援多種儲存後端\n */\n\nexport class StorageAdapter {\n  /**\n   * 儲存音訊檔案\n   * @param {Blob} blob - 音訊 Blob 物件\n   * @param {string} filename - 檔案名稱\n   * @param {Object} metadata - 元數據（可選）\n   * @returns {Promise<string>} 檔案 ID 或 URL\n   */\n  async save(blob, filename, metadata = {}) {\n    throw new Error('save() must be implemented by subclass');\n  }\n  \n  /**\n   * 載入音訊檔案\n   * @param {string} id - 檔案 ID 或名稱\n   * @returns {Promise<Blob>} 音訊 Blob 物件\n   */\n  async load(id) {\n    throw new Error('load() must be implemented by subclass');\n  }\n  \n  /**\n   * 刪除音訊檔案\n   * @param {string} id - 檔案 ID 或名稱\n   * @returns {Promise<boolean>} 是否成功刪除\n   */\n  async delete(id) {\n    throw new Error('delete() must be implemented by subclass');\n  }\n  \n  /**\n   * 列出所有檔案\n   * @returns {Promise<Array>} 檔案列表\n   */\n  async list() {\n    throw new Error('list() must be implemented by subclass');\n  }\n  \n  /**\n   * 檢查檔案是否存在\n   * @param {string} id - 檔案 ID 或名稱\n   * @returns {Promise<boolean>}\n   */\n  async exists(id) {\n    try {\n      await this.load(id);\n      return true;\n    } catch (error) {\n      return false;\n    }\n  }\n  \n  /**\n   * 清空所有檔案（謹慎使用）\n   * @returns {Promise<number>} 刪除的檔案數量\n   */\n  async clear() {\n    const files = await this.list();\n    let count = 0;\n    \n    for (const file of files) {\n      try {\n        await this.delete(file.id || file.filename);\n        count++;\n      } catch (error) {\n        console.error('Failed to delete file:', file, error);\n      }\n    }\n    \n    return count;\n  }\n}\n\nexport default StorageAdapter;\n","/**\n * VoiceBank Recorder - 主入口點\n * 跨平台音訊錄音庫\n * \n * @version 1.0.0\n * @author VoiceBank Team\n * @license MIT\n */\n\n// 匯出核心模組\nexport { AudioEngine } from './core/AudioEngine.js';\n\n// 匯出儲存模組\nexport {\n  StorageAdapter,\n  IndexedDBAdapter,\n  ServerAdapter,\n  ElectronAdapter,\n  CapacitorAdapter,\n  StorageFactory\n} from './storage/index.js';\n\n// 匯出工具模組\nexport { PlatformDetector } from './utils/PlatformDetector.js';\n\n/**\n * VoiceBankRecorder - 主類別\n * 提供統一的 API 介面\n */\nexport class VoiceBankRecorder {\n  /**\n   * 建構函數\n   * @param {Object} options - 配置選項\n   * @param {string|HTMLElement} options.container - 容器選擇器或元素\n   * @param {string} options.layout - 佈局模式 ('horizontal'|'vertical'|'auto')\n   * @param {string} options.theme - 主題 ('light'|'dark')\n   * @param {Object} options.audio - 音訊配置\n   * @param {Object} options.waveform - 波形配置\n   * @param {Object} options.storage - 儲存配置\n   * @param {Object} options.callbacks - 事件回調\n   */\n  constructor(options = {}) {\n    this.options = this.mergeOptions(options);\n    this.initialized = false;\n    \n    // 初始化儲存適配器\n    this.storage = this.createStorageAdapter(this.options.storage);\n    \n    // 狀態\n    this.isRecording = false;\n    this.isPaused = false;\n    this.currentBlob = null;\n    \n    // 如果提供了容器，初始化 UI\n    if (this.options.container) {\n      this.initializeUI();\n    }\n  }\n  \n  /**\n   * 合併配置選項\n   * @param {Object} options - 用戶選項\n   * @returns {Object} 合併後的選項\n   */\n  mergeOptions(options) {\n    const defaults = {\n      container: null,\n      layout: 'auto',\n      theme: 'light',\n      \n      audio: {\n        sampleRate: 48000,\n        channels: 1,\n        agc: false,\n        gain: 1.0\n      },\n      \n      waveform: {\n        showOverview: true,\n        showAccumulated: true,\n        showLive: true,\n        decimation: 10,\n        colors: {\n          waveform: '#1E88E5',\n          selection: '#4CAF50',\n          playback: '#FF0000'\n        }\n      },\n      \n      storage: {\n        type: 'auto'\n      },\n      \n      callbacks: {\n        onRecordStart: () => {},\n        onRecordStop: () => {},\n        onRecordPause: () => {},\n        onRecordResume: () => {},\n        onPlayStart: () => {},\n        onPlayStop: () => {},\n        onError: (error) => console.error('VoiceBankRecorder error:', error)\n      }\n    };\n    \n    // 深度合併\n    return this.deepMerge(defaults, options);\n  }\n  \n  /**\n   * 深度合併物件\n   * @param {Object} target - 目標物件\n   * @param {Object} source - 來源物件\n   * @returns {Object}\n   */\n  deepMerge(target, source) {\n    const result = { ...target };\n    \n    for (const key in source) {\n      if (source[key] instanceof Object && !Array.isArray(source[key])) {\n        result[key] = this.deepMerge(result[key] || {}, source[key]);\n      } else {\n        result[key] = source[key];\n      }\n    }\n    \n    return result;\n  }\n  \n  /**\n   * 創建儲存適配器\n   * @param {Object} storageConfig - 儲存配置\n   * @returns {StorageAdapter}\n   */\n  createStorageAdapter(storageConfig) {\n    const { StorageFactory } = require('./storage/index.js');\n    return StorageFactory.create({\n      type: storageConfig.type || 'auto',\n      options: storageConfig\n    });\n  }\n  \n  /**\n   * 初始化 UI\n   */\n  initializeUI() {\n    // TODO: 實作 UI 初始化\n    // 這將在後續階段實作\n    console.log('UI initialization - to be implemented');\n  }\n  \n  /**\n   * 開始錄音\n   * @returns {Promise<void>}\n   */\n  async startRecording() {\n    try {\n      if (this.isRecording) {\n        throw new Error('Already recording');\n      }\n      \n      // TODO: 實作錄音邏輯\n      this.isRecording = true;\n      this.options.callbacks.onRecordStart();\n      \n      console.log('Recording started');\n    } catch (error) {\n      this.options.callbacks.onError(error);\n      throw error;\n    }\n  }\n  \n  /**\n   * 停止錄音\n   * @returns {Promise<Blob>}\n   */\n  async stopRecording() {\n    try {\n      if (!this.isRecording) {\n        throw new Error('Not recording');\n      }\n      \n      // TODO: 實作停止錄音邏輯\n      this.isRecording = false;\n      \n      // 模擬返回 Blob（實際會從 AudioEngine 獲取）\n      this.currentBlob = null; // TODO: 實際的 Blob\n      \n      this.options.callbacks.onRecordStop(this.currentBlob);\n      \n      console.log('Recording stopped');\n      return this.currentBlob;\n    } catch (error) {\n      this.options.callbacks.onError(error);\n      throw error;\n    }\n  }\n  \n  /**\n   * 暫停錄音\n   * @returns {Promise<void>}\n   */\n  async pauseRecording() {\n    try {\n      if (!this.isRecording || this.isPaused) {\n        throw new Error('Cannot pause');\n      }\n      \n      this.isPaused = true;\n      this.options.callbacks.onRecordPause();\n      \n      console.log('Recording paused');\n    } catch (error) {\n      this.options.callbacks.onError(error);\n      throw error;\n    }\n  }\n  \n  /**\n   * 恢復錄音\n   * @returns {Promise<void>}\n   */\n  async resumeRecording() {\n    try {\n      if (!this.isRecording || !this.isPaused) {\n        throw new Error('Cannot resume');\n      }\n      \n      this.isPaused = false;\n      this.options.callbacks.onRecordResume();\n      \n      console.log('Recording resumed');\n    } catch (error) {\n      this.options.callbacks.onError(error);\n      throw error;\n    }\n  }\n  \n  /**\n   * 播放錄音\n   * @returns {Promise<void>}\n   */\n  async play() {\n    try {\n      // TODO: 實作播放邏輯\n      this.options.callbacks.onPlayStart();\n      \n      console.log('Playback started');\n    } catch (error) {\n      this.options.callbacks.onError(error);\n      throw error;\n    }\n  }\n  \n  /**\n   * 停止播放\n   * @returns {Promise<void>}\n   */\n  async stop() {\n    try {\n      // TODO: 實作停止播放邏輯\n      this.options.callbacks.onPlayStop();\n      \n      console.log('Playback stopped');\n    } catch (error) {\n      this.options.callbacks.onError(error);\n      throw error;\n    }\n  }\n  \n  /**\n   * 儲存錄音\n   * @param {Blob} blob - 音訊 Blob（可選，使用當前錄音）\n   * @param {string} filename - 檔案名稱（可選，自動生成）\n   * @param {Object} metadata - 元數據（可選）\n   * @returns {Promise<string>} 檔案 ID\n   */\n  async saveRecording(blob = null, filename = null, metadata = {}) {\n    try {\n      const blobToSave = blob || this.currentBlob;\n      \n      if (!blobToSave) {\n        throw new Error('No recording to save');\n      }\n      \n      const filenameToUse = filename || `recording-${Date.now()}.wav`;\n      \n      const id = await this.storage.save(blobToSave, filenameToUse, metadata);\n      \n      console.log('Recording saved:', id);\n      return id;\n    } catch (error) {\n      this.options.callbacks.onError(error);\n      throw error;\n    }\n  }\n  \n  /**\n   * 載入錄音\n   * @param {string} id - 檔案 ID\n   * @returns {Promise<Blob>}\n   */\n  async loadRecording(id) {\n    try {\n      const blob = await this.storage.load(id);\n      this.currentBlob = blob;\n      \n      console.log('Recording loaded:', id);\n      return blob;\n    } catch (error) {\n      this.options.callbacks.onError(error);\n      throw error;\n    }\n  }\n  \n  /**\n   * 刪除錄音\n   * @param {string} id - 檔案 ID\n   * @returns {Promise<boolean>}\n   */\n  async deleteRecording(id) {\n    try {\n      const result = await this.storage.delete(id);\n      \n      console.log('Recording deleted:', id);\n      return result;\n    } catch (error) {\n      this.options.callbacks.onError(error);\n      throw error;\n    }\n  }\n  \n  /**\n   * 列出所有錄音\n   * @returns {Promise<Array>}\n   */\n  async listRecordings() {\n    try {\n      const recordings = await this.storage.list();\n      \n      console.log('Recordings listed:', recordings.length);\n      return recordings;\n    } catch (error) {\n      this.options.callbacks.onError(error);\n      throw error;\n    }\n  }\n  \n  /**\n   * 取得當前錄音 Blob\n   * @returns {Blob|null}\n   */\n  getCurrentBlob() {\n    return this.currentBlob;\n  }\n  \n  /**\n   * 銷毀實例\n   */\n  destroy() {\n    // TODO: 清理資源\n    this.isRecording = false;\n    this.isPaused = false;\n    this.currentBlob = null;\n    \n    if (this.storage && typeof this.storage.close === 'function') {\n      this.storage.close();\n    }\n    \n    console.log('VoiceBankRecorder destroyed');\n  }\n}\n\n// 預設導出\nexport default VoiceBankRecorder;\n\n/**\n * 版本資訊\n */\nexport const VERSION = '1.0.0';\n\n/**\n * 建置資訊\n */\nexport const BUILD_INFO = {\n  version: VERSION,\n  date: new Date().toISOString(),\n  name: 'VoiceBank Recorder'\n};\n","/**\n * AudioEngine - 跨平台音訊錄音引擎\n * \n * 功能：\n * - 封裝 Web Audio API (AudioContext, AudioWorklet)\n * - 支援 RecordRTC 錄音 (WAV 格式)\n * - 自動處理 AudioWorklet 與 ScriptProcessor fallback\n * - 提供錄音控制 (開始/停止/暫停/繼續)\n * - 事件驅動架構 (recording-start, data-available, recording-stop 等)\n * - 麥克風輸入管理與前級增益控制\n * \n * @example\n * const engine = new AudioEngine({\n *   sampleRate: 48000,\n *   autoGainControl: false,\n *   micGain: 1.0\n * });\n * \n * engine.on('recording-start', () => console.log('Started'));\n * engine.on('data-available', (pcmData) => console.log('PCM chunk', pcmData));\n * engine.on('recording-stop', (blob) => console.log('Finished', blob));\n * \n * await engine.initialize();\n * await engine.startRecording();\n * // ... 錄音中 ...\n * await engine.stopRecording();\n */\n\nexport class AudioEngine {\n    /**\n     * 創建 AudioEngine 實例\n     * @param {Object} options - 配置選項\n     * @param {number} [options.sampleRate=48000] - 採樣率\n     * @param {boolean} [options.autoGainControl=false] - 自動增益控制\n     * @param {boolean} [options.echoCancellation=false] - 回音消除\n     * @param {boolean} [options.noiseSuppression=false] - 噪音抑制\n     * @param {number} [options.micGain=1.0] - 前級增益 (1.0-6.0)\n     * @param {string} [options.deviceId] - 麥克風設備 ID\n     * @param {string} [options.workletPath='assets/js/worklet/pcm-collector.js'] - AudioWorklet 模組路徑\n     * @param {boolean} [options.preferWorklet=true] - 優先使用 AudioWorklet（支援時）\n     */\n    constructor(options = {}) {\n        // 配置選項\n        this.config = {\n            sampleRate: options.sampleRate || 48000,\n            autoGainControl: options.autoGainControl !== undefined ? options.autoGainControl : false,\n            echoCancellation: options.echoCancellation !== undefined ? options.echoCancellation : false,\n            noiseSuppression: options.noiseSuppression !== undefined ? options.noiseSuppression : false,\n            micGain: options.micGain || 1.0,\n            deviceId: options.deviceId || null,\n            workletPath: options.workletPath || 'assets/js/worklet/pcm-collector.js',\n            preferWorklet: options.preferWorklet !== undefined ? options.preferWorklet : true\n        };\n\n        // Web Audio API 物件\n        this.audioContext = null;\n        this.analyser = null;\n        this.preGainNode = null;\n        this.mediaDest = null;\n        this.analyserSilencer = null;\n\n        // AudioWorklet 相關\n        this.workletSupported = false;\n        this.workletLoaded = false;\n        this.pcmCollectorNode = null;\n        this.usingWorklet = false;\n\n        // PCM 數據收集 (AudioWorklet 模式)\n        this.pcmChunks = [];\n        this.pcmTotalSamples = 0;\n\n        // RecordRTC 錄音器\n        this.recorder = null;\n\n        // 麥克風串流\n        this.micStream = null;\n\n        // 錄音狀態\n        this.isRecording = false;\n        this.isPaused = false;\n        this.isInitialized = false;\n\n        // 時間戳記\n        this.recordStartTime = 0;\n        this.recordStopTime = 0;\n        this.recordWallStartMs = 0;\n        this.recordWallStopMs = 0;\n\n        // 最後的錄音結果\n        this.latestBlob = null;\n        this.latestUrl = null;\n\n        // 事件監聽器\n        this._eventListeners = {};\n    }\n\n    /**\n     * 初始化音訊引擎\n     * 創建 AudioContext、Analyser、Gain 節點等\n     * @returns {Promise<void>}\n     */\n    async initialize() {\n        if (this.isInitialized) {\n            return;\n        }\n\n        try {\n            // 創建 AudioContext\n            const AudioContextClass = window.AudioContext || window.webkitAudioContext;\n            this.audioContext = new AudioContextClass({ sampleRate: this.config.sampleRate });\n\n            // 創建分析器節點\n            this.analyser = this.audioContext.createAnalyser();\n            this.analyser.fftSize = 256;\n\n            // 創建前級增益節點\n            this.preGainNode = this.audioContext.createGain();\n            this.preGainNode.gain.value = this.config.micGain;\n\n            // 創建 MediaStreamDestination（供 RecordRTC 使用）\n            this.mediaDest = this.audioContext.createMediaStreamDestination();\n\n            // 連接節點：preGain -> analyser -> silencer -> destination\n            this.preGainNode.connect(this.analyser);\n            this.preGainNode.connect(this.mediaDest);\n\n            // 創建靜音節點（避免回授）\n            this.analyserSilencer = this.audioContext.createGain();\n            this.analyserSilencer.gain.value = 0;\n            this.analyser.connect(this.analyserSilencer);\n            this.analyserSilencer.connect(this.audioContext.destination);\n\n            // 檢測 AudioWorklet 支援\n            this.workletSupported = !!(\n                this.audioContext.audioWorklet && \n                window.AudioWorkletNode\n            );\n\n            // 載入 AudioWorklet 模組（如果支援且偏好使用）\n            if (this.workletSupported && this.config.preferWorklet) {\n                try {\n                    await this.audioContext.audioWorklet.addModule(this.config.workletPath);\n                    this.workletLoaded = true;\n                    this._emit('worklet-loaded', { path: this.config.workletPath });\n                } catch (error) {\n                    console.warn('載入 AudioWorklet 模組失敗，將回退到 RecordRTC:', error);\n                    this.workletLoaded = false;\n                    this._emit('worklet-load-failed', { error });\n                }\n            }\n\n            // 恢復 AudioContext（如果暫停）\n            if (this.audioContext.state === 'suspended') {\n                await this.audioContext.resume();\n            }\n\n            this.isInitialized = true;\n            this._emit('initialized', {\n                sampleRate: this.audioContext.sampleRate,\n                state: this.audioContext.state,\n                workletSupported: this.workletSupported,\n                workletLoaded: this.workletLoaded\n            });\n\n        } catch (error) {\n            this._emit('error', { stage: 'initialize', error });\n            throw error;\n        }\n    }\n\n    /**\n     * 開始錄音\n     * @returns {Promise<void>}\n     */\n    async startRecording() {\n        if (!this.isInitialized) {\n            throw new Error('AudioEngine 尚未初始化，請先調用 initialize()');\n        }\n\n        if (this.isRecording) {\n            throw new Error('已經在錄音中');\n        }\n\n        try {\n            // 確保 AudioContext 是活躍狀態\n            if (this.audioContext.state === 'suspended') {\n                await this.audioContext.resume();\n            }\n\n            // 獲取麥克風\n            await this._captureMicrophone();\n\n            // 重置 PCM 數據收集\n            this.pcmChunks = [];\n            this.pcmTotalSamples = 0;\n\n            // 清理舊的錄音結果\n            if (this.latestUrl) {\n                URL.revokeObjectURL(this.latestUrl);\n                this.latestUrl = null;\n            }\n            this.latestBlob = null;\n\n            // 記錄開始時間\n            this.recordStartTime = Date.now();\n            this.recordWallStartMs = performance.now();\n            this.recordStopTime = 0;\n            this.recordWallStopMs = 0;\n\n            // 決定使用 AudioWorklet 或 RecordRTC\n            const useWorklet = this.workletLoaded && this.config.preferWorklet;\n\n            if (useWorklet) {\n                await this._startWorkletRecording();\n            } else {\n                await this._startRecordRTCRecording();\n            }\n\n            this.isRecording = true;\n            this.isPaused = false;\n\n            this._emit('recording-start', {\n                timestamp: this.recordStartTime,\n                mode: useWorklet ? 'worklet' : 'recordrtc',\n                sampleRate: this.audioContext.sampleRate\n            });\n\n        } catch (error) {\n            this._emit('error', { stage: 'start-recording', error });\n            throw error;\n        }\n    }\n\n    /**\n     * 停止錄音\n     * @returns {Promise<Blob>} 錄音的 Blob\n     */\n    async stopRecording() {\n        if (!this.isRecording) {\n            throw new Error('目前沒有在錄音');\n        }\n\n        try {\n            this.isRecording = false;\n            this.recordStopTime = Date.now();\n            this.recordWallStopMs = performance.now();\n\n            let blob;\n\n            if (this.usingWorklet) {\n                blob = await this._stopWorkletRecording();\n            } else if (this.recorder) {\n                blob = await this._stopRecordRTCRecording();\n            } else {\n                throw new Error('沒有可用的錄音器');\n            }\n\n            // 停止麥克風\n            this._stopMicrophone();\n\n            // 儲存結果\n            this.latestBlob = blob;\n            this.latestUrl = URL.createObjectURL(blob);\n\n            const duration = (this.recordStopTime - this.recordStartTime) / 1000;\n\n            this._emit('recording-stop', {\n                blob,\n                url: this.latestUrl,\n                duration,\n                samples: this.pcmTotalSamples,\n                sampleRate: this.audioContext.sampleRate\n            });\n\n            return blob;\n\n        } catch (error) {\n            this._emit('error', { stage: 'stop-recording', error });\n            throw error;\n        }\n    }\n\n    /**\n     * 暫停錄音（僅 RecordRTC 模式支援）\n     */\n    pauseRecording() {\n        if (!this.isRecording) {\n            throw new Error('目前沒有在錄音');\n        }\n\n        if (this.usingWorklet) {\n            throw new Error('AudioWorklet 模式不支援暫停功能');\n        }\n\n        if (this.recorder && typeof this.recorder.pauseRecording === 'function') {\n            this.recorder.pauseRecording();\n            this.isPaused = true;\n            this._emit('recording-paused', { timestamp: Date.now() });\n        } else {\n            throw new Error('暫停功能不可用');\n        }\n    }\n\n    /**\n     * 繼續錄音（僅 RecordRTC 模式支援）\n     */\n    resumeRecording() {\n        if (!this.isPaused) {\n            throw new Error('錄音沒有暫停');\n        }\n\n        if (this.recorder && typeof this.recorder.resumeRecording === 'function') {\n            this.recorder.resumeRecording();\n            this.isPaused = false;\n            this._emit('recording-resumed', { timestamp: Date.now() });\n        } else {\n            throw new Error('繼續錄音功能不可用');\n        }\n    }\n\n    /**\n     * 取得最新的錄音數據\n     * @returns {Object} { blob, url, duration, samples }\n     */\n    getLatestRecording() {\n        return {\n            blob: this.latestBlob,\n            url: this.latestUrl,\n            duration: this.latestBlob ? (this.recordStopTime - this.recordStartTime) / 1000 : 0,\n            samples: this.pcmTotalSamples,\n            sampleRate: this.audioContext ? this.audioContext.sampleRate : 0\n        };\n    }\n\n    /**\n     * 取得 PCM 數據視窗（僅 AudioWorklet 模式）\n     * @param {number} start - 起始樣本索引\n     * @param {number} count - 樣本數量\n     * @returns {Float32Array|null}\n     */\n    getPcmWindow(start, count) {\n        if (!this.usingWorklet || !this.pcmChunks.length) {\n            return null;\n        }\n\n        if (start < 0) start = 0;\n        const total = this.pcmTotalSamples;\n        if (start >= total) return new Float32Array(0);\n\n        const end = Math.min(total, start + count);\n        const out = new Float32Array(end - start);\n        let offset = 0;\n        let passed = 0;\n\n        for (let i = 0; i < this.pcmChunks.length && passed < end; i++) {\n            const chunk = this.pcmChunks[i];\n            if (!chunk || !chunk.length) continue;\n\n            const cLen = chunk.length;\n            const cStart = passed;\n            const cEnd = passed + cLen;\n\n            if (cEnd <= start) {\n                passed = cEnd;\n                continue;\n            }\n\n            const segStart = Math.max(start, cStart);\n            const segEnd = Math.min(end, cEnd);\n\n            if (segEnd > segStart) {\n                const localStart = segStart - cStart;\n                const slice = chunk.subarray(localStart, localStart + (segEnd - segStart));\n                out.set(slice, offset);\n                offset += slice.length;\n            }\n\n            passed = cEnd;\n            if (segEnd >= end) break;\n        }\n\n        return out;\n    }\n\n    /**\n     * 取得 Analyser 節點（供外部波形顯示使用）\n     * @returns {AnalyserNode|null}\n     */\n    getAnalyser() {\n        return this.analyser;\n    }\n\n    /**\n     * 取得 AudioContext\n     * @returns {AudioContext|null}\n     */\n    getAudioContext() {\n        return this.audioContext;\n    }\n\n    /**\n     * 設定前級增益\n     * @param {number} gain - 增益值 (1.0-6.0)\n     */\n    setMicGain(gain) {\n        gain = Math.max(1.0, Math.min(6.0, gain));\n        this.config.micGain = gain;\n\n        if (this.preGainNode) {\n            this.preGainNode.gain.value = gain;\n        }\n\n        this._emit('mic-gain-changed', { gain });\n    }\n\n    /**\n     * 釋放資源\n     */\n    dispose() {\n        if (this.isRecording) {\n            this.stopRecording().catch(console.error);\n        }\n\n        this._stopMicrophone();\n\n        if (this.latestUrl) {\n            URL.revokeObjectURL(this.latestUrl);\n            this.latestUrl = null;\n        }\n\n        if (this.audioContext) {\n            this.audioContext.close().catch(console.error);\n            this.audioContext = null;\n        }\n\n        this.analyser = null;\n        this.preGainNode = null;\n        this.mediaDest = null;\n        this.analyserSilencer = null;\n        this.pcmCollectorNode = null;\n        this.recorder = null;\n\n        this.pcmChunks = [];\n        this.pcmTotalSamples = 0;\n\n        this.isInitialized = false;\n\n        this._emit('disposed');\n    }\n\n    // ============================================================\n    // 事件系統\n    // ============================================================\n\n    /**\n     * 註冊事件監聽器\n     * @param {string} event - 事件名稱\n     * @param {Function} handler - 處理函數\n     */\n    on(event, handler) {\n        if (!this._eventListeners[event]) {\n            this._eventListeners[event] = [];\n        }\n        this._eventListeners[event].push(handler);\n    }\n\n    /**\n     * 移除事件監聽器\n     * @param {string} event - 事件名稱\n     * @param {Function} handler - 處理函數\n     */\n    off(event, handler) {\n        if (!this._eventListeners[event]) return;\n\n        const index = this._eventListeners[event].indexOf(handler);\n        if (index > -1) {\n            this._eventListeners[event].splice(index, 1);\n        }\n    }\n\n    /**\n     * 觸發事件（內部使用）\n     * @private\n     */\n    _emit(event, data) {\n        if (!this._eventListeners[event]) return;\n\n        this._eventListeners[event].forEach(handler => {\n            try {\n                handler(data);\n            } catch (error) {\n                console.error(`事件處理器錯誤 [${event}]:`, error);\n            }\n        });\n    }\n\n    // ============================================================\n    // 私有方法 - 麥克風捕獲\n    // ============================================================\n\n    async _captureMicrophone() {\n        const constraints = {\n            audio: {\n                echoCancellation: this.config.echoCancellation,\n                noiseSuppression: this.config.noiseSuppression,\n                autoGainControl: this.config.autoGainControl\n            },\n            video: false\n        };\n\n        // 加入設備 ID 限制（如果有指定）\n        if (this.config.deviceId) {\n            constraints.audio.deviceId = { exact: this.config.deviceId };\n        }\n\n        try {\n            this.micStream = await navigator.mediaDevices.getUserMedia(constraints);\n\n            // iOS 自動增益調整\n            this._applyIOSMicGainAdjustment();\n\n            // 連接麥克風到前級增益節點\n            const source = this.audioContext.createMediaStreamSource(this.micStream);\n            source.connect(this.preGainNode);\n\n            this._emit('microphone-captured', {\n                deviceId: this.config.deviceId,\n                constraints\n            });\n\n        } catch (error) {\n            // 如果指定設備失敗，嘗試使用預設設備\n            if (error.name === 'OverconstrainedError' || error.name === 'NotFoundError') {\n                console.warn('指定的麥克風無法使用，嘗試預設設備');\n\n                delete constraints.audio.deviceId;\n                this.micStream = await navigator.mediaDevices.getUserMedia(constraints);\n\n                this._applyIOSMicGainAdjustment();\n\n                const source = this.audioContext.createMediaStreamSource(this.micStream);\n                source.connect(this.preGainNode);\n\n                this._emit('microphone-captured-fallback', { constraints });\n            } else {\n                throw error;\n            }\n        }\n    }\n\n    _stopMicrophone() {\n        if (this.micStream) {\n            this.micStream.getTracks().forEach(track => {\n                try {\n                    track.stop();\n                } catch (error) {\n                    console.warn('停止麥克風軌道失敗:', error);\n                }\n            });\n            this.micStream = null;\n        }\n    }\n\n    _applyIOSMicGainAdjustment() {\n        // iOS 上 AGC 關閉時音量偏低，自動提升增益\n        try {\n            const ua = navigator.userAgent || '';\n            const isIOS = /iphone|ipad|ipod/i.test(ua);\n\n            if (isIOS && !this.config.autoGainControl) {\n                if (Math.abs(this.config.micGain - 1.0) < 0.0001) {\n                    this.setMicGain(3.5);\n                    this._emit('ios-gain-adjusted', { gain: 3.5 });\n                }\n            }\n        } catch (error) {\n            console.warn('iOS 增益調整失敗:', error);\n        }\n    }\n\n    // ============================================================\n    // 私有方法 - AudioWorklet 錄音\n    // ============================================================\n\n    async _startWorkletRecording() {\n        try {\n            // 創建 AudioWorkletNode\n            this.pcmCollectorNode = new AudioWorkletNode(\n                this.audioContext,\n                'pcm-collector-processor'\n            );\n\n            // 監聽 PCM 數據\n            this.pcmCollectorNode.port.onmessage = (event) => {\n                const { type, pcmData } = event.data;\n\n                if (type === 'pcm-data' && pcmData) {\n                    this.pcmChunks.push(new Float32Array(pcmData));\n                    this.pcmTotalSamples += pcmData.length;\n\n                    this._emit('data-available', {\n                        pcmData: new Float32Array(pcmData),\n                        totalSamples: this.pcmTotalSamples,\n                        mode: 'worklet'\n                    });\n                }\n            };\n\n            // 連接節點：preGain -> pcmCollector -> analyser\n            this.preGainNode.connect(this.pcmCollectorNode);\n            this.pcmCollectorNode.connect(this.audioContext.destination);\n\n            this.usingWorklet = true;\n\n        } catch (error) {\n            console.error('AudioWorklet 啟動失敗，回退到 RecordRTC:', error);\n            this.usingWorklet = false;\n            await this._startRecordRTCRecording();\n        }\n    }\n\n    async _stopWorkletRecording() {\n        try {\n            // 斷開 AudioWorkletNode\n            if (this.pcmCollectorNode) {\n                this.pcmCollectorNode.port.onmessage = null;\n                this.preGainNode.disconnect(this.pcmCollectorNode);\n                this.pcmCollectorNode.disconnect();\n                this.pcmCollectorNode = null;\n            }\n\n            // 合併 PCM 數據並轉換為 WAV\n            if (this.pcmChunks.length === 0) {\n                throw new Error('沒有錄音數據');\n            }\n\n            const merged = new Float32Array(this.pcmTotalSamples);\n            let offset = 0;\n\n            for (const chunk of this.pcmChunks) {\n                merged.set(chunk, offset);\n                offset += chunk.length;\n            }\n\n            // 轉換為 16-bit PCM WAV\n            const wavBuffer = this._buildWavFromFloat32Mono(\n                merged,\n                this.audioContext.sampleRate\n            );\n\n            const blob = new Blob([wavBuffer], { type: 'audio/wav' });\n\n            this.usingWorklet = false;\n\n            return blob;\n\n        } catch (error) {\n            console.error('AudioWorklet 停止失敗:', error);\n            throw error;\n        }\n    }\n\n    // ============================================================\n    // 私有方法 - RecordRTC 錄音\n    // ============================================================\n\n    async _startRecordRTCRecording() {\n        return new Promise((resolve, reject) => {\n            try {\n                // 檢查 RecordRTC 是否可用\n                if (typeof RecordRTC === 'undefined') {\n                    reject(new Error('RecordRTC 未載入'));\n                    return;\n                }\n\n                const recordStream = this.mediaDest.stream || this.micStream;\n\n                this.recorder = RecordRTC(recordStream, {\n                    type: 'audio',\n                    mimeType: 'audio/wav',\n                    recorderType: StereoAudioRecorder,\n                    numberOfAudioChannels: 1,\n                    bufferSize: 4096,\n                    timeSlice: 100,\n                    ondataavailable: (blob) => {\n                        this._emit('data-available', {\n                            blob,\n                            mode: 'recordrtc'\n                        });\n                    }\n                });\n\n                this.recorder.startRecording();\n                this.usingWorklet = false;\n\n                resolve();\n\n            } catch (error) {\n                reject(error);\n            }\n        });\n    }\n\n    async _stopRecordRTCRecording() {\n        return new Promise((resolve, reject) => {\n            try {\n                if (!this.recorder) {\n                    reject(new Error('RecordRTC 錄音器不存在'));\n                    return;\n                }\n\n                this.recorder.stopRecording(() => {\n                    try {\n                        const blob = this.recorder.getBlob();\n\n                        // 清理錄音器\n                        this.recorder = null;\n\n                        resolve(blob);\n                    } catch (error) {\n                        reject(error);\n                    }\n                });\n\n            } catch (error) {\n                reject(error);\n            }\n        });\n    }\n\n    // ============================================================\n    // 私有方法 - WAV 格式轉換\n    // ============================================================\n\n    _buildWavFromFloat32Mono(float32Data, sampleRate) {\n        const numSamples = float32Data.length;\n        const buffer = new ArrayBuffer(44 + numSamples * 2);\n        const view = new DataView(buffer);\n\n        // WAV Header\n        this._writeString(view, 0, 'RIFF');\n        view.setUint32(4, 36 + numSamples * 2, true);\n        this._writeString(view, 8, 'WAVE');\n        this._writeString(view, 12, 'fmt ');\n        view.setUint32(16, 16, true); // fmt chunk size\n        view.setUint16(20, 1, true);  // audio format (PCM)\n        view.setUint16(22, 1, true);  // number of channels\n        view.setUint32(24, sampleRate, true);\n        view.setUint32(28, sampleRate * 2, true); // byte rate\n        view.setUint16(32, 2, true);  // block align\n        view.setUint16(34, 16, true); // bits per sample\n        this._writeString(view, 36, 'data');\n        view.setUint32(40, numSamples * 2, true);\n\n        // PCM Data (float32 -> int16)\n        let offset = 44;\n        for (let i = 0; i < numSamples; i++) {\n            const sample = Math.max(-1, Math.min(1, float32Data[i]));\n            const int16 = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;\n            view.setInt16(offset, int16, true);\n            offset += 2;\n        }\n\n        return buffer;\n    }\n\n    _writeString(view, offset, string) {\n        for (let i = 0; i < string.length; i++) {\n            view.setUint8(offset + i, string.charCodeAt(i));\n        }\n    }\n}\n\nexport default AudioEngine;\n","/**\n * CapacitorAdapter - Capacitor 檔案系統儲存適配器\n * 使用 Capacitor Filesystem Plugin 在移動裝置上儲存檔案\n */\n\nimport { StorageAdapter } from './StorageAdapter.js';\n\nexport class CapacitorAdapter extends StorageAdapter {\n  /**\n   * 建構函數\n   * @param {string} directory - 儲存目錄名稱\n   */\n  constructor(directory = 'recordings') {\n    super();\n    this.directory = directory;\n    \n    // 檢查 Capacitor 是否可用\n    if (typeof window === 'undefined' || !window.Capacitor) {\n      throw new Error('Capacitor not available. Make sure Capacitor is properly initialized.');\n    }\n    \n    this.Capacitor = window.Capacitor;\n    this.initialized = false;\n  }\n  \n  /**\n   * 初始化（確保目錄存在）\n   * @returns {Promise<void>}\n   */\n  async initialize() {\n    if (this.initialized) return;\n    \n    try {\n      const { Filesystem, Directory } = this.Capacitor.Plugins;\n      \n      // 嘗試讀取目錄，如果不存在則創建\n      try {\n        await Filesystem.readdir({\n          path: this.directory,\n          directory: Directory.Documents\n        });\n      } catch (e) {\n        // 目錄不存在，創建它\n        await Filesystem.mkdir({\n          path: this.directory,\n          directory: Directory.Documents,\n          recursive: true\n        });\n      }\n      \n      this.initialized = true;\n    } catch (error) {\n      console.error('Capacitor initialization error:', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * 儲存音訊檔案\n   * @param {Blob} blob - 音訊 Blob\n   * @param {string} filename - 檔案名稱\n   * @param {Object} metadata - 元數據\n   * @returns {Promise<string>} 檔案名稱\n   */\n  async save(blob, filename, metadata = {}) {\n    await this.initialize();\n    \n    try {\n      const { Filesystem, Directory } = this.Capacitor.Plugins;\n      \n      // 轉換 Blob 為 base64\n      const base64Data = await this.blobToBase64(blob);\n      \n      // 儲存音訊檔案\n      await Filesystem.writeFile({\n        path: `${this.directory}/${filename}`,\n        data: base64Data,\n        directory: Directory.Documents\n      });\n      \n      // 儲存元數據\n      if (metadata && Object.keys(metadata).length > 0) {\n        const metadataWithDefaults = {\n          ...metadata,\n          size: blob.size,\n          type: blob.type,\n          timestamp: Date.now()\n        };\n        \n        await Filesystem.writeFile({\n          path: `${this.directory}/${filename}.meta.json`,\n          data: JSON.stringify(metadataWithDefaults),\n          directory: Directory.Documents,\n          encoding: 'utf8'\n        });\n      }\n      \n      return filename;\n    } catch (error) {\n      console.error('Capacitor save error:', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * 載入音訊檔案\n   * @param {string} filename - 檔案名稱\n   * @returns {Promise<Blob>}\n   */\n  async load(filename) {\n    await this.initialize();\n    \n    try {\n      const { Filesystem, Directory } = this.Capacitor.Plugins;\n      \n      const result = await Filesystem.readFile({\n        path: `${this.directory}/${filename}`,\n        directory: Directory.Documents\n      });\n      \n      // 將 base64 轉換為 Blob\n      return this.base64ToBlob(result.data, 'audio/wav');\n    } catch (error) {\n      console.error('Capacitor load error:', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * 刪除音訊檔案\n   * @param {string} filename - 檔案名稱\n   * @returns {Promise<boolean>}\n   */\n  async delete(filename) {\n    await this.initialize();\n    \n    try {\n      const { Filesystem, Directory } = this.Capacitor.Plugins;\n      \n      // 刪除音訊檔案\n      await Filesystem.deleteFile({\n        path: `${this.directory}/${filename}`,\n        directory: Directory.Documents\n      });\n      \n      // 嘗試刪除元數據（如果存在）\n      try {\n        await Filesystem.deleteFile({\n          path: `${this.directory}/${filename}.meta.json`,\n          directory: Directory.Documents\n        });\n      } catch (e) {\n        // 元數據可能不存在，忽略錯誤\n      }\n      \n      return true;\n    } catch (error) {\n      console.error('Capacitor delete error:', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * 列出所有檔案\n   * @returns {Promise<Array>}\n   */\n  async list() {\n    await this.initialize();\n    \n    try {\n      const { Filesystem, Directory } = this.Capacitor.Plugins;\n      \n      const result = await Filesystem.readdir({\n        path: this.directory,\n        directory: Directory.Documents\n      });\n      \n      // 過濾掉元數據檔案，只保留音訊檔案\n      const audioFiles = result.files.filter(f => !f.endsWith('.meta.json'));\n      \n      // 為每個檔案載入元數據\n      const recordings = await Promise.all(\n        audioFiles.map(async (filename) => {\n          let metadata = {};\n          \n          try {\n            const metaResult = await Filesystem.readFile({\n              path: `${this.directory}/${filename}.meta.json`,\n              directory: Directory.Documents,\n              encoding: 'utf8'\n            });\n            metadata = JSON.parse(metaResult.data);\n          } catch (e) {\n            // 沒有元數據\n          }\n          \n          return {\n            id: filename,\n            filename: filename,\n            metadata: metadata,\n            timestamp: metadata.timestamp || 0,\n            date: metadata.timestamp ? new Date(metadata.timestamp) : null,\n            size: metadata.size || 0,\n            type: metadata.type || 'audio/wav'\n          };\n        })\n      );\n      \n      // 按時間排序（最新的在前）\n      recordings.sort((a, b) => b.timestamp - a.timestamp);\n      \n      return recordings;\n    } catch (error) {\n      console.error('Capacitor list error:', error);\n      return [];\n    }\n  }\n  \n  /**\n   * 取得檔案的 URI（用於播放）\n   * @param {string} filename - 檔案名稱\n   * @returns {Promise<string>} 檔案 URI\n   */\n  async getUri(filename) {\n    await this.initialize();\n    \n    try {\n      const { Filesystem, Directory } = this.Capacitor.Plugins;\n      \n      const result = await Filesystem.getUri({\n        path: `${this.directory}/${filename}`,\n        directory: Directory.Documents\n      });\n      \n      return result.uri;\n    } catch (error) {\n      console.error('Capacitor getUri error:', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Blob 轉 base64\n   * @param {Blob} blob\n   * @returns {Promise<string>}\n   */\n  blobToBase64(blob) {\n    return new Promise((resolve, reject) => {\n      const reader = new FileReader();\n      reader.onloadend = () => {\n        // 移除 data:audio/wav;base64, 前綴\n        const base64 = reader.result.split(',')[1];\n        resolve(base64);\n      };\n      reader.onerror = reject;\n      reader.readAsDataURL(blob);\n    });\n  }\n  \n  /**\n   * base64 轉 Blob\n   * @param {string} base64\n   * @param {string} mimeType\n   * @returns {Blob}\n   */\n  base64ToBlob(base64, mimeType = 'audio/wav') {\n    const byteCharacters = atob(base64);\n    const byteNumbers = new Array(byteCharacters.length);\n    \n    for (let i = 0; i < byteCharacters.length; i++) {\n      byteNumbers[i] = byteCharacters.charCodeAt(i);\n    }\n    \n    const byteArray = new Uint8Array(byteNumbers);\n    return new Blob([byteArray], { type: mimeType });\n  }\n  \n  /**\n   * 取得儲存空間資訊\n   * @returns {Promise<Object>}\n   */\n  async getStorageInfo() {\n    const recordings = await this.list();\n    const totalSize = recordings.reduce((sum, r) => sum + (r.size || 0), 0);\n    \n    return {\n      count: recordings.length,\n      totalSize: totalSize,\n      totalSizeMB: (totalSize / (1024 * 1024)).toFixed(2),\n      recordings: recordings\n    };\n  }\n}\n\nexport default CapacitorAdapter;\n","/**\n * ElectronAdapter - Electron 檔案系統儲存適配器\n * 使用 Electron 的 IPC 通訊與主進程進行檔案操作\n */\n\nimport { StorageAdapter } from './StorageAdapter.js';\n\nexport class ElectronAdapter extends StorageAdapter {\n  /**\n   * 建構函數\n   * @param {string} savePath - 預設儲存路徑（相對於用戶文件目錄）\n   */\n  constructor(savePath = 'recordings') {\n    super();\n    this.savePath = savePath;\n    \n    // 檢查 Electron API 是否可用\n    if (typeof window === 'undefined' || !window.electronAPI) {\n      throw new Error('Electron API not available. Make sure preload script is properly configured.');\n    }\n    \n    this.electronAPI = window.electronAPI;\n  }\n  \n  /**\n   * 儲存音訊檔案\n   * @param {Blob} blob - 音訊 Blob\n   * @param {string} filename - 檔案名稱\n   * @param {Object} metadata - 元數據\n   * @returns {Promise<string>} 檔案路徑\n   */\n  async save(blob, filename, metadata = {}) {\n    try {\n      // 將 Blob 轉換為 ArrayBuffer\n      const arrayBuffer = await blob.arrayBuffer();\n      \n      // 轉換為普通陣列（以便通過 IPC 傳遞）\n      const buffer = Array.from(new Uint8Array(arrayBuffer));\n      \n      // 呼叫 Electron API\n      const result = await this.electronAPI.saveRecording({\n        filename,\n        buffer,\n        metadata: {\n          ...metadata,\n          size: blob.size,\n          type: blob.type,\n          timestamp: Date.now()\n        }\n      });\n      \n      if (result.success) {\n        return result.id || result.path;\n      } else {\n        throw new Error(result.error || 'Save failed');\n      }\n    } catch (error) {\n      console.error('Electron save error:', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * 載入音訊檔案\n   * @param {string} filePath - 檔案路徑\n   * @returns {Promise<Blob>}\n   */\n  async load(filePath) {\n    try {\n      // 從 Electron 讀取檔案\n      const buffer = await this.electronAPI.loadRecording(filePath);\n      \n      // 將 Buffer 轉換為 Blob\n      const uint8Array = new Uint8Array(buffer);\n      return new Blob([uint8Array], { type: 'audio/wav' });\n    } catch (error) {\n      console.error('Electron load error:', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * 刪除音訊檔案\n   * @param {string} filePath - 檔案路徑\n   * @returns {Promise<boolean>}\n   */\n  async delete(filePath) {\n    try {\n      const result = await this.electronAPI.deleteRecording(filePath);\n      return result.success;\n    } catch (error) {\n      console.error('Electron delete error:', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * 列出所有檔案\n   * @param {string} directory - 目錄路徑（可選）\n   * @returns {Promise<Array>}\n   */\n  async list(directory = null) {\n    try {\n      const recordings = await this.electronAPI.listRecordings(directory);\n      return recordings || [];\n    } catch (error) {\n      console.error('Electron list error:', error);\n      return [];\n    }\n  }\n  \n  /**\n   * 開啟檔案選擇對話框\n   * @returns {Promise<string|null>} 選擇的檔案路徑\n   */\n  async openFile() {\n    try {\n      if (this.electronAPI.openFile) {\n        return await this.electronAPI.openFile();\n      }\n      throw new Error('openFile API not available');\n    } catch (error) {\n      console.error('Electron openFile error:', error);\n      return null;\n    }\n  }\n  \n  /**\n   * 開啟另存為對話框\n   * @param {Blob} blob - 要儲存的 Blob\n   * @param {string} defaultFilename - 預設檔案名稱\n   * @returns {Promise<string|null>} 儲存的檔案路徑\n   */\n  async saveAs(blob, defaultFilename = 'recording.wav') {\n    try {\n      const arrayBuffer = await blob.arrayBuffer();\n      const buffer = Array.from(new Uint8Array(arrayBuffer));\n      \n      if (this.electronAPI.saveAs) {\n        const result = await this.electronAPI.saveAs({\n          filename: defaultFilename,\n          buffer\n        });\n        \n        return result.success ? result.path : null;\n      }\n      \n      // 如果沒有 saveAs API，使用預設的 save\n      return await this.save(blob, defaultFilename);\n    } catch (error) {\n      console.error('Electron saveAs error:', error);\n      return null;\n    }\n  }\n  \n  /**\n   * 在檔案管理器中顯示檔案\n   * @param {string} filePath - 檔案路徑\n   * @returns {Promise<boolean>}\n   */\n  async showInFolder(filePath) {\n    try {\n      if (this.electronAPI.showInFolder) {\n        await this.electronAPI.showInFolder(filePath);\n        return true;\n      }\n      return false;\n    } catch (error) {\n      console.error('Electron showInFolder error:', error);\n      return false;\n    }\n  }\n}\n\nexport default ElectronAdapter;\n","/**\n * IndexedDBAdapter - IndexedDB 儲存實現\n * 用於瀏覽器端本地儲存，無需伺服器\n */\n\nimport { StorageAdapter } from './StorageAdapter.js';\n\nexport class IndexedDBAdapter extends StorageAdapter {\n  /**\n   * 建構函數\n   * @param {string} dbName - 資料庫名稱\n   * @param {string} storeName - 儲存區名稱\n   * @param {number} version - 資料庫版本\n   */\n  constructor(dbName = 'VoiceBankDB', storeName = 'recordings', version = 1) {\n    super();\n    this.dbName = dbName;\n    this.storeName = storeName;\n    this.version = version;\n    this.db = null;\n  }\n  \n  /**\n   * 初始化資料庫\n   * @returns {Promise<IDBDatabase>}\n   */\n  async initialize() {\n    if (this.db) {\n      return this.db;\n    }\n    \n    return new Promise((resolve, reject) => {\n      const request = indexedDB.open(this.dbName, this.version);\n      \n      request.onerror = () => {\n        reject(new Error(`Failed to open IndexedDB: ${request.error}`));\n      };\n      \n      request.onsuccess = () => {\n        this.db = request.result;\n        resolve(this.db);\n      };\n      \n      request.onupgradeneeded = (event) => {\n        const db = event.target.result;\n        \n        // 創建物件儲存區（如果不存在）\n        if (!db.objectStoreNames.contains(this.storeName)) {\n          const store = db.createObjectStore(this.storeName, { \n            keyPath: 'id', \n            autoIncrement: true \n          });\n          \n          // 創建索引\n          store.createIndex('filename', 'filename', { unique: false });\n          store.createIndex('timestamp', 'timestamp', { unique: false });\n          store.createIndex('duration', 'duration', { unique: false });\n        }\n      };\n    });\n  }\n  \n  /**\n   * 儲存音訊檔案\n   * @param {Blob} blob - 音訊 Blob\n   * @param {string} filename - 檔案名稱\n   * @param {Object} metadata - 元數據\n   * @returns {Promise<string>} 檔案 ID\n   */\n  async save(blob, filename, metadata = {}) {\n    await this.initialize();\n    \n    return new Promise((resolve, reject) => {\n      const transaction = this.db.transaction([this.storeName], 'readwrite');\n      const store = transaction.objectStore(this.storeName);\n      \n      const record = {\n        filename: filename,\n        blob: blob,\n        size: blob.size,\n        type: blob.type,\n        timestamp: Date.now(),\n        metadata: metadata\n      };\n      \n      const request = store.add(record);\n      \n      request.onsuccess = () => {\n        resolve(String(request.result));\n      };\n      \n      request.onerror = () => {\n        reject(new Error(`Failed to save recording: ${request.error}`));\n      };\n      \n      transaction.onerror = () => {\n        reject(new Error(`Transaction failed: ${transaction.error}`));\n      };\n    });\n  }\n  \n  /**\n   * 載入音訊檔案\n   * @param {string} id - 檔案 ID\n   * @returns {Promise<Blob>}\n   */\n  async load(id) {\n    await this.initialize();\n    \n    return new Promise((resolve, reject) => {\n      const transaction = this.db.transaction([this.storeName], 'readonly');\n      const store = transaction.objectStore(this.storeName);\n      const request = store.get(Number(id));\n      \n      request.onsuccess = () => {\n        const record = request.result;\n        if (record && record.blob) {\n          resolve(record.blob);\n        } else {\n          reject(new Error(`Recording not found: ${id}`));\n        }\n      };\n      \n      request.onerror = () => {\n        reject(new Error(`Failed to load recording: ${request.error}`));\n      };\n    });\n  }\n  \n  /**\n   * 刪除音訊檔案\n   * @param {string} id - 檔案 ID\n   * @returns {Promise<boolean>}\n   */\n  async delete(id) {\n    await this.initialize();\n    \n    return new Promise((resolve, reject) => {\n      const transaction = this.db.transaction([this.storeName], 'readwrite');\n      const store = transaction.objectStore(this.storeName);\n      const request = store.delete(Number(id));\n      \n      request.onsuccess = () => {\n        resolve(true);\n      };\n      \n      request.onerror = () => {\n        reject(new Error(`Failed to delete recording: ${request.error}`));\n      };\n    });\n  }\n  \n  /**\n   * 列出所有檔案\n   * @returns {Promise<Array>}\n   */\n  async list() {\n    await this.initialize();\n    \n    return new Promise((resolve, reject) => {\n      const transaction = this.db.transaction([this.storeName], 'readonly');\n      const store = transaction.objectStore(this.storeName);\n      const request = store.getAll();\n      \n      request.onsuccess = () => {\n        const records = request.result.map(record => ({\n          id: String(record.id),\n          filename: record.filename,\n          size: record.size,\n          type: record.type,\n          timestamp: record.timestamp,\n          date: new Date(record.timestamp),\n          metadata: record.metadata || {}\n        }));\n        resolve(records);\n      };\n      \n      request.onerror = () => {\n        reject(new Error(`Failed to list recordings: ${request.error}`));\n      };\n    });\n  }\n  \n  /**\n   * 根據檔名搜尋\n   * @param {string} filename - 檔案名稱（支援部分匹配）\n   * @returns {Promise<Array>}\n   */\n  async searchByFilename(filename) {\n    const allRecords = await this.list();\n    return allRecords.filter(record => \n      record.filename.toLowerCase().includes(filename.toLowerCase())\n    );\n  }\n  \n  /**\n   * 取得儲存空間使用情況\n   * @returns {Promise<Object>}\n   */\n  async getStorageInfo() {\n    const records = await this.list();\n    const totalSize = records.reduce((sum, record) => sum + record.size, 0);\n    \n    return {\n      count: records.length,\n      totalSize: totalSize,\n      totalSizeMB: (totalSize / (1024 * 1024)).toFixed(2),\n      records: records\n    };\n  }\n  \n  /**\n   * 清空所有錄音\n   * @returns {Promise<number>} 刪除的數量\n   */\n  async clear() {\n    await this.initialize();\n    \n    return new Promise((resolve, reject) => {\n      const transaction = this.db.transaction([this.storeName], 'readwrite');\n      const store = transaction.objectStore(this.storeName);\n      \n      // 先取得數量\n      const countRequest = store.count();\n      \n      countRequest.onsuccess = () => {\n        const count = countRequest.result;\n        \n        // 清空儲存區\n        const clearRequest = store.clear();\n        \n        clearRequest.onsuccess = () => {\n          resolve(count);\n        };\n        \n        clearRequest.onerror = () => {\n          reject(new Error(`Failed to clear recordings: ${clearRequest.error}`));\n        };\n      };\n      \n      countRequest.onerror = () => {\n        reject(new Error(`Failed to count recordings: ${countRequest.error}`));\n      };\n    });\n  }\n  \n  /**\n   * 取得瀏覽器儲存空間配額資訊（如果可用）\n   * @returns {Promise<Object|null>}\n   */\n  async getStorageEstimate() {\n    if ('storage' in navigator && 'estimate' in navigator.storage) {\n      try {\n        const estimate = await navigator.storage.estimate();\n        return {\n          usage: estimate.usage,\n          quota: estimate.quota,\n          usageMB: (estimate.usage / (1024 * 1024)).toFixed(2),\n          quotaMB: (estimate.quota / (1024 * 1024)).toFixed(2),\n          usagePercent: ((estimate.usage / estimate.quota) * 100).toFixed(2)\n        };\n      } catch (error) {\n        console.warn('Failed to get storage estimate:', error);\n        return null;\n      }\n    }\n    return null;\n  }\n  \n  /**\n   * 關閉資料庫連接\n   */\n  close() {\n    if (this.db) {\n      this.db.close();\n      this.db = null;\n    }\n  }\n}\n\nexport default IndexedDBAdapter;\n","/**\n * PlatformDetector - 平台偵測工具\n * 自動偵測當前運行環境（Browser/Electron/Capacitor）\n */\n\nexport class PlatformDetector {\n  /**\n   * 偵測當前平台\n   * @returns {string} 'browser' | 'electron' | 'capacitor'\n   */\n  static detect() {\n    // 檢查是否為 Electron\n    if (typeof window !== 'undefined' && window.electronAPI) {\n      return 'electron';\n    }\n    \n    // 檢查是否為 Electron（另一種方式）\n    if (typeof process !== 'undefined' && process.versions && process.versions.electron) {\n      return 'electron';\n    }\n    \n    // 檢查是否為 Capacitor\n    if (typeof window !== 'undefined' && window.Capacitor) {\n      return 'capacitor';\n    }\n    \n    // 預設為瀏覽器\n    return 'browser';\n  }\n  \n  /**\n   * 檢查是否為 Electron 環境\n   * @returns {boolean}\n   */\n  static isElectron() {\n    return this.detect() === 'electron';\n  }\n  \n  /**\n   * 檢查是否為 Capacitor 環境\n   * @returns {boolean}\n   */\n  static isCapacitor() {\n    return this.detect() === 'capacitor';\n  }\n  \n  /**\n   * 檢查是否為瀏覽器環境\n   * @returns {boolean}\n   */\n  static isBrowser() {\n    return this.detect() === 'browser';\n  }\n  \n  /**\n   * 檢查是否為移動裝置\n   * @returns {boolean}\n   */\n  static isMobile() {\n    if (typeof window === 'undefined' || !window.navigator) {\n      return false;\n    }\n    \n    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(\n      window.navigator.userAgent\n    );\n  }\n  \n  /**\n   * 檢查是否支援 AudioWorklet\n   * @returns {boolean}\n   */\n  static supportsAudioWorklet() {\n    if (typeof window === 'undefined' || !window.AudioContext) {\n      return false;\n    }\n    \n    const AudioContextClass = window.AudioContext || window.webkitAudioContext;\n    return 'audioWorklet' in AudioContextClass.prototype;\n  }\n  \n  /**\n   * 檢查是否支援 OffscreenCanvas\n   * @returns {boolean}\n   */\n  static supportsOffscreenCanvas() {\n    return typeof OffscreenCanvas !== 'undefined';\n  }\n  \n  /**\n   * 取得平台資訊\n   * @returns {Object}\n   */\n  static getInfo() {\n    return {\n      platform: this.detect(),\n      isElectron: this.isElectron(),\n      isCapacitor: this.isCapacitor(),\n      isBrowser: this.isBrowser(),\n      isMobile: this.isMobile(),\n      supportsAudioWorklet: this.supportsAudioWorklet(),\n      supportsOffscreenCanvas: this.supportsOffscreenCanvas(),\n      userAgent: typeof navigator !== 'undefined' ? navigator.userAgent : 'unknown'\n    };\n  }\n}\n\nexport default PlatformDetector;\n","/**\n * ServerAdapter - 伺服器儲存適配器\n * 支援 PHP/Node.js 等後端儲存方案\n */\n\nimport { StorageAdapter } from './StorageAdapter.js';\n\nexport class ServerAdapter extends StorageAdapter {\n  /**\n   * 建構函數\n   * @param {Object} config - 配置選項\n   * @param {string} config.baseURL - 基礎 URL\n   * @param {string} config.saveEndpoint - 上傳端點\n   * @param {string} config.loadEndpoint - 下載端點\n   * @param {string} config.deleteEndpoint - 刪除端點\n   * @param {string} config.listEndpoint - 列表端點（可選）\n   */\n  constructor(config = {}) {\n    super();\n    this.baseURL = config.baseURL || '';\n    this.saveEndpoint = config.saveEndpoint || '/backend/save.php';\n    this.loadEndpoint = config.loadEndpoint || '/public/uploads/';\n    this.deleteEndpoint = config.deleteEndpoint || '/backend/delete.php';\n    this.listEndpoint = config.listEndpoint || '/api/recordings';\n    this.headers = config.headers || {};\n  }\n  \n  /**\n   * 儲存音訊檔案\n   * @param {Blob} blob - 音訊 Blob\n   * @param {string} filename - 檔案名稱\n   * @param {Object} metadata - 元數據\n   * @returns {Promise<string>} 檔案名稱\n   */\n  async save(blob, filename, metadata = {}) {\n    const formData = new FormData();\n    formData.append('audio-blob', blob);\n    formData.append('audio-filename', filename);\n    \n    if (metadata && Object.keys(metadata).length > 0) {\n      formData.append('metadata', JSON.stringify(metadata));\n    }\n    \n    try {\n      const response = await fetch(this.baseURL + this.saveEndpoint, {\n        method: 'POST',\n        body: formData,\n        headers: this.headers\n      });\n      \n      if (!response.ok) {\n        throw new Error(`Upload failed: ${response.status} ${response.statusText}`);\n      }\n      \n      const result = await response.text();\n      \n      // 檢查 PHP 端點的回應（通常是 'success'）\n      if (result.toLowerCase().includes('success')) {\n        return filename;\n      } else {\n        throw new Error(`Server error: ${result}`);\n      }\n    } catch (error) {\n      console.error('Save error:', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * 載入音訊檔案\n   * @param {string} filename - 檔案名稱\n   * @returns {Promise<Blob>}\n   */\n  async load(filename) {\n    try {\n      const url = this.baseURL + this.loadEndpoint + filename;\n      const response = await fetch(url, {\n        headers: this.headers\n      });\n      \n      if (!response.ok) {\n        throw new Error(`Load failed: ${response.status} ${response.statusText}`);\n      }\n      \n      return await response.blob();\n    } catch (error) {\n      console.error('Load error:', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * 刪除音訊檔案\n   * @param {string} filename - 檔案名稱\n   * @returns {Promise<boolean>}\n   */\n  async delete(filename) {\n    try {\n      const response = await fetch(this.baseURL + this.deleteEndpoint, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          ...this.headers\n        },\n        body: JSON.stringify({ filename })\n      });\n      \n      if (!response.ok) {\n        throw new Error(`Delete failed: ${response.status} ${response.statusText}`);\n      }\n      \n      const result = await response.text();\n      return result.toLowerCase().includes('success');\n    } catch (error) {\n      console.error('Delete error:', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * 列出所有檔案\n   * @returns {Promise<Array>}\n   */\n  async list() {\n    try {\n      const response = await fetch(this.baseURL + this.listEndpoint, {\n        headers: this.headers\n      });\n      \n      if (!response.ok) {\n        throw new Error(`List failed: ${response.status} ${response.statusText}`);\n      }\n      \n      const data = await response.json();\n      return Array.isArray(data) ? data : [];\n    } catch (error) {\n      console.error('List error:', error);\n      // 如果後端不支援 list 操作，返回空陣列\n      return [];\n    }\n  }\n  \n  /**\n   * 使用 XMLHttpRequest 上傳（帶進度回調）\n   * @param {Blob} blob - 音訊 Blob\n   * @param {string} filename - 檔案名稱\n   * @param {Object} metadata - 元數據\n   * @param {Function} onProgress - 進度回調 (percent)\n   * @returns {Promise<string>}\n   */\n  async saveWithProgress(blob, filename, metadata = {}, onProgress = null) {\n    return new Promise((resolve, reject) => {\n      const formData = new FormData();\n      formData.append('audio-blob', blob);\n      formData.append('audio-filename', filename);\n      \n      if (metadata && Object.keys(metadata).length > 0) {\n        formData.append('metadata', JSON.stringify(metadata));\n      }\n      \n      const xhr = new XMLHttpRequest();\n      \n      // 進度事件\n      if (onProgress) {\n        xhr.upload.addEventListener('progress', (e) => {\n          if (e.lengthComputable) {\n            const percent = (e.loaded / e.total) * 100;\n            onProgress(percent);\n          }\n        });\n      }\n      \n      // 完成事件\n      xhr.addEventListener('load', () => {\n        if (xhr.status >= 200 && xhr.status < 300) {\n          const result = xhr.responseText;\n          if (result.toLowerCase().includes('success')) {\n            resolve(filename);\n          } else {\n            reject(new Error(`Server error: ${result}`));\n          }\n        } else {\n          reject(new Error(`Upload failed: ${xhr.status} ${xhr.statusText}`));\n        }\n      });\n      \n      // 錯誤事件\n      xhr.addEventListener('error', () => {\n        reject(new Error('Network error during upload'));\n      });\n      \n      // 取消事件\n      xhr.addEventListener('abort', () => {\n        reject(new Error('Upload cancelled'));\n      });\n      \n      // 發送請求\n      xhr.open('POST', this.baseURL + this.saveEndpoint);\n      \n      // 設定自定義 headers\n      Object.keys(this.headers).forEach(key => {\n        xhr.setRequestHeader(key, this.headers[key]);\n      });\n      \n      xhr.send(formData);\n    });\n  }\n}\n\nexport default ServerAdapter;\n","/**\n * Storage Module - 儲存模組統一入口\n * 匯出所有儲存適配器\n */\n\nexport { StorageAdapter } from './StorageAdapter.js';\nexport { IndexedDBAdapter } from './IndexedDBAdapter.js';\nexport { ServerAdapter } from './ServerAdapter.js';\nexport { ElectronAdapter } from './ElectronAdapter.js';\nexport { CapacitorAdapter } from './CapacitorAdapter.js';\n\n/**\n * StorageFactory - 儲存適配器工廠\n * 根據配置自動創建適當的儲存適配器\n */\nexport class StorageFactory {\n  /**\n   * 創建儲存適配器\n   * @param {Object} config - 配置選項\n   * @param {string} config.type - 儲存類型 ('browser'|'electron'|'capacitor'|'server'|'auto')\n   * @param {Object} config.options - 適配器特定選項\n   * @returns {StorageAdapter}\n   */\n  static create(config = {}) {\n    const type = config.type || 'auto';\n    const options = config.options || {};\n    \n    // 自動偵測\n    if (type === 'auto') {\n      return this.createAuto(options);\n    }\n    \n    // 根據類型創建\n    switch (type.toLowerCase()) {\n      case 'browser':\n      case 'indexeddb':\n        const { IndexedDBAdapter } = require('./IndexedDBAdapter.js');\n        return new IndexedDBAdapter(\n          options.dbName,\n          options.storeName,\n          options.version\n        );\n      \n      case 'electron':\n        const { ElectronAdapter } = require('./ElectronAdapter.js');\n        return new ElectronAdapter(options.savePath);\n      \n      case 'capacitor':\n        const { CapacitorAdapter } = require('./CapacitorAdapter.js');\n        return new CapacitorAdapter(options.directory);\n      \n      case 'server':\n      case 'php':\n      case 'nodejs':\n        const { ServerAdapter } = require('./ServerAdapter.js');\n        return new ServerAdapter(options);\n      \n      default:\n        throw new Error(`Unknown storage type: ${type}`);\n    }\n  }\n  \n  /**\n   * 自動創建適配器（根據環境）\n   * @param {Object} options - 選項\n   * @returns {StorageAdapter}\n   */\n  static createAuto(options = {}) {\n    // 檢查 Electron\n    if (typeof window !== 'undefined' && window.electronAPI) {\n      const { ElectronAdapter } = require('./ElectronAdapter.js');\n      return new ElectronAdapter(options.savePath);\n    }\n    \n    // 檢查 Capacitor\n    if (typeof window !== 'undefined' && window.Capacitor) {\n      const { CapacitorAdapter } = require('./CapacitorAdapter.js');\n      return new CapacitorAdapter(options.directory);\n    }\n    \n    // 預設使用 IndexedDB（瀏覽器）\n    const { IndexedDBAdapter } = require('./IndexedDBAdapter.js');\n    return new IndexedDBAdapter(\n      options.dbName,\n      options.storeName,\n      options.version\n    );\n  }\n}\n\nexport default StorageFactory;\n"],"names":["StorageAdapter","save","blob","filename","metadata","Error","load","id","delete","list","exists","this","error","clear","files","count","file","console","VoiceBankRecorder","constructor","options","mergeOptions","initialized","storage","createStorageAdapter","isRecording","isPaused","currentBlob","container","initializeUI","defaults","layout","theme","audio","sampleRate","channels","agc","gain","waveform","showOverview","showAccumulated","showLive","decimation","colors","selection","playback","type","callbacks","onRecordStart","onRecordStop","onRecordPause","onRecordResume","onPlayStart","onPlayStop","onError","deepMerge","target","source","result","key","Object","Array","isArray","storageConfig","StorageFactory","require","create","log","startRecording","stopRecording","pauseRecording","resumeRecording","play","stop","saveRecording","blobToSave","filenameToUse","Date","now","loadRecording","deleteRecording","listRecordings","recordings","length","getCurrentBlob","destroy","close","VERSION","BUILD_INFO","version","date","toISOString","name","config","autoGainControl","undefined","echoCancellation","noiseSuppression","micGain","deviceId","workletPath","preferWorklet","audioContext","analyser","preGainNode","mediaDest","analyserSilencer","workletSupported","workletLoaded","pcmCollectorNode","usingWorklet","pcmChunks","pcmTotalSamples","recorder","micStream","isInitialized","recordStartTime","recordStopTime","recordWallStartMs","recordWallStopMs","latestBlob","latestUrl","_eventListeners","initialize","AudioContextClass","window","AudioContext","webkitAudioContext","createAnalyser","fftSize","createGain","value","createMediaStreamDestination","connect","destination","audioWorklet","AudioWorkletNode","addModule","_emit","path","warn","state","resume","stage","_captureMicrophone","URL","revokeObjectURL","performance","useWorklet","_startWorkletRecording","_startRecordRTCRecording","timestamp","mode","_stopWorkletRecording","_stopRecordRTCRecording","_stopMicrophone","createObjectURL","duration","url","samples","getLatestRecording","getPcmWindow","start","total","Float32Array","end","Math","min","out","offset","passed","i","chunk","cStart","cEnd","segStart","max","segEnd","localStart","slice","subarray","set","getAnalyser","getAudioContext","setMicGain","dispose","catch","on","event","handler","push","off","index","indexOf","splice","data","forEach","constraints","video","exact","navigator","mediaDevices","getUserMedia","_applyIOSMicGainAdjustment","createMediaStreamSource","getTracks","track","ua","userAgent","test","abs","port","onmessage","pcmData","totalSamples","disconnect","merged","wavBuffer","_buildWavFromFloat32Mono","Blob","Promise","resolve","reject","RecordRTC","recordStream","stream","mimeType","recorderType","StereoAudioRecorder","numberOfAudioChannels","bufferSize","timeSlice","ondataavailable","getBlob","float32Data","numSamples","buffer","ArrayBuffer","view","DataView","_writeString","setUint32","setUint16","sample","int16","setInt16","string","setUint8","charCodeAt","directory","super","Capacitor","Filesystem","Directory","Plugins","readdir","Documents","e","mkdir","recursive","base64Data","blobToBase64","writeFile","keys","metadataWithDefaults","size","JSON","stringify","encoding","readFile","base64ToBlob","deleteFile","audioFiles","filter","f","endsWith","all","map","async","metaResult","parse","sort","a","b","getUri","uri","reader","FileReader","onloadend","base64","split","onerror","readAsDataURL","byteCharacters","atob","byteNumbers","byteArray","Uint8Array","getStorageInfo","totalSize","reduce","sum","r","totalSizeMB","toFixed","savePath","electronAPI","arrayBuffer","from","success","filePath","uint8Array","openFile","saveAs","defaultFilename","showInFolder","dbName","storeName","db","request","indexedDB","open","onsuccess","onupgradeneeded","objectStoreNames","contains","store","createObjectStore","keyPath","autoIncrement","createIndex","unique","transaction","objectStore","record","add","String","get","Number","getAll","records","searchByFilename","toLowerCase","includes","countRequest","clearRequest","getStorageEstimate","estimate","usage","quota","usageMB","quotaMB","usagePercent","detect","process","versions","electron","isElectron","isCapacitor","isBrowser","isMobile","supportsAudioWorklet","prototype","supportsOffscreenCanvas","OffscreenCanvas","getInfo","platform","baseURL","saveEndpoint","loadEndpoint","deleteEndpoint","listEndpoint","headers","formData","FormData","append","response","fetch","method","body","ok","status","statusText","text","json","saveWithProgress","onProgress","xhr","XMLHttpRequest","upload","addEventListener","lengthComputable","percent","loaded","responseText","setRequestHeader","send","createAuto","IndexedDBAdapter","ElectronAdapter","CapacitorAdapter","ServerAdapter"],"mappings":"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"}