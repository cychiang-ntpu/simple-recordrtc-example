<!DOCTYPE html>
<head>
    <title>Process RAW PCM data using RecordRTC</title>
    <meta charset="utf-8">
    <link rel="stylesheet" href="assets/css/style.css">
</head>

<body>
<h1>Process RAW PCM data using RecordRTC</h1>
<h2>請念：以二號女友為例，她堅持不下廚，你要娶一個巧婦，就形成對立局面。</h2>
<h3>length</h3>
<h4>what?</h4>



<br>
<button id="btn-start-recording">開始錄音</button>
<button id="btn-stop-recording" disabled>結束錄音</button>

<br>

<canvas id="view1" width="750" height="200"></canvas>

<br>

<audio controls playsinline></audio>


<hr>

<div id="audio-blobs-container" style="margin-top: 20px;">
    <h2 style="margin-bottom: 20px;">Audio Blobs Goes Here:</h2>
</div>

<script src="assets/js/RecordRTC.js"></script>

<script>
    var audio = document.querySelector('audio');
    var audioBlobsContainer = document.querySelector('#audio-blobs-container');
    var is_ready_to_record = true;
    var is_recording = false;
    var is_recorded = false;

    var audioContext = new (window.AudioContext || window.webkitAudioContext)();
    var analyser = audioContext.createAnalyser();
    var dataArray = new Uint8Array(analyser.frequencyBinCount);

    function calculateTimeDuration(secs) {
        var hr = Math.floor(secs / 3600);
        var min = Math.floor((secs - (hr * 3600)) / 60);
        var sec = Math.floor(secs - (hr * 3600) - (min * 60));

        if (min < 10) {
            min = "0" + min;
        }

        if (sec < 10) {
            sec = "0" + sec;
        }

        if(hr <= 0) {
            return min + ':' + sec;
        }

        return hr + ':' + min + ':' + sec;
    }

    function captureMicrophone(callback) {
        navigator.mediaDevices.getUserMedia({audio: {
                    echoCancellation: false,
                    noiseSuppression: false,
                    autoGainControl: false
                    },
                    video: false
            }
        ).then(function(microphone) {
            callback(microphone);
        }).catch(function(error) {
            alert('Unable to capture your microphone. Please check console logs.');
            console.error(error);
        });
    }

    function stopRecordingCallback() {
        // ------------------------------------------------------------
        // get access to StereoAudioRecorder object (name as "internal-recorder")
        // ------------------------------------------------------------
        var internalRecorder = recorder.getInternalRecorder();
        
        // ------------------------------------------------------------
        // get left and right audio channels
        // ------------------------------------------------------------
        var leftchannel = internalRecorder.leftchannel;
        var rightchannel = internalRecorder.rightchannel;

        // ------------------------------------------------------------
        // create your own WAV
        // ------------------------------------------------------------
        mergeLeftRightBuffers({
            desiredSampRate: internalRecorder.desiredSampRate,
            sampleRate: internalRecorder.sampleRate,
            numberOfAudioChannels: internalRecorder.numberOfAudioChannels,
            internalInterleavedLength: internalRecorder.recordingLength,
            leftBuffers: leftchannel,
            rightBuffers: internalRecorder.numberOfAudioChannels === 1 ? [] : rightchannel
        }, function(buffer, view) {
            // ------------------------------------------------------------
            // here is your own WAV (generated by your own codes)
            // ------------------------------------------------------------
            var blob = new Blob([buffer], {
                type: 'audio/wav'
            });
            audio.srcObject = null;
            audio.src = URL.createObjectURL(blob);
        });

        recorder.microphone.stop();
        var button = this;
        uploadToServer(recorder, function(progress, fileURL) {
            if(progress === 'ended') {
                button.disabled = false;
                button.innerHTML = 'Click to download from server';
                button.onclick = function() {
                    window.open(fileURL);
                };
                return;
            }
            button.innerHTML = progress;
        });

        var listOfFilesUploaded = [];

        function uploadToServer(recordRTC, callback) {
            var blob = recordRTC instanceof Blob ? recordRTC : recordRTC.blob;
            var fileType = blob.type.split('/')[0] || 'audio';
            var fileName = 'xxx_' + (Math.random() * 1000).toString().replace('.', '');
            
            if (fileType === 'audio') {
                fileName += '.' + (!!navigator.mozGetUserMedia ? 'ogg' : 'wav');
            } else {
                fileName += '.webm';
            }

            // create FormData
            var formData = new FormData();
            formData.append(fileType + '-filename', fileName);
            formData.append(fileType + '-blob', blob);

            callback('Uploading ' + fileType + ' recording to server.');

            // var upload_url = 'https://your-domain.com/files-uploader/';
            var upload_url = 'save.php';

            // var upload_directory = upload_url;
            var upload_directory = 'uploads/';

            makeXMLHttpRequest(upload_url, formData, function(progress) {
                if (progress !== 'upload-ended') {
                    callback(progress);
                    return;
                }

                callback('ended', upload_directory + fileName);

                // to make sure we can delete as soon as visitor leaves
                listOfFilesUploaded.push(upload_directory + fileName);
            });
        }

        function makeXMLHttpRequest(url, data, callback) {
            var request = new XMLHttpRequest();
            request.onreadystatechange = function() {
                if (request.readyState == 4 && request.status == 200) {
                    callback('upload-ended');
                }
            };

            request.upload.onloadstart = function() {
                callback('Upload started...');
            };

            request.upload.onprogress = function(event) {
                callback('Upload Progress ' + Math.round(event.loaded / event.total * 100) + "%");
            };

            request.upload.onload = function() {
                callback('progress-about-to-end');
            };

            request.upload.onload = function() {
                callback('progress-ended');
            };

            request.upload.onerror = function(error) {
                callback('Failed to upload to server');
                console.error('XMLHttpRequest failed', error);
            };

            request.upload.onabort = function(error) {
                callback('Upload aborted.');
                console.error('XMLHttpRequest aborted', error);
            };

            request.open('POST', url);
            request.send(data);
        }
        recorder = null;
    }

    var recorder; // globally accessible

    document.getElementById('btn-start-recording').onclick = function() {
        this.disabled = true;
        is_ready_to_record = false;
        is_recording = true;
        is_recorded = false;

        let element = audioBlobsContainer;
        while (element.firstChild) {
            element.removeChild(element.firstChild);
        }

        captureMicrophone(function(microphone) {
            audio.srcObject = microphone;

            recorder = RecordRTC(microphone, {
                type: 'audio',
                mimeType: 'audio/wav',
                recorderType: StereoAudioRecorder,
                numberOfAudioChannels: 1,
                //sampleRate: 48000,
                //desiredSampRate: 48000,
                bufferSize: 16384,
                timeSlice: 1000, // pass this parameter
                ondataavailable: function(blob) {
                    
                    function convertBlobToAudioBuffer(myBlob) {
                        const audioContext = new AudioContext();
                        const fileReader = new FileReader();

                        fileReader.onloadend = () => {

                            let myArrayBuffer = fileReader.result;

                            audioContext.decodeAudioData(myArrayBuffer, (audioBuffer) => {
                                // Do something with audioBuffer
                                console.log(audioBuffer);
                                function drawBuffer( width, height, context, buffer ) {
                                    var data = buffer.getChannelData( 0 );
                                    var step = Math.ceil( data.length / width );
                                    //var step = data.length / width;
                                    //var step = data.length / 48000;
                                    var amp = height / 2;
                                    for(var i=0; i < width; i++){
                                        var min = 1.0;
                                        var max = -1.0;
                                        for (var j=0; j<step; j++) {
                                            var datum = data[(i*step)+j]; 
                                            if (datum < min)
                                                min = datum;
                                            if (datum > max)
                                                max = datum;
                                        }
                                        context.fillRect(i,(1+min)*amp,1,Math.max(1,(max-min)*amp));
                                    }
                                    //context.clearRect(0,0,750,200);
                                    //requestAnimFrame(drawBuffer.bind(this));
                                }
                                var canvas = document.getElementById("view1");
                                drawBuffer( canvas.width, canvas.height, canvas.getContext('2d'), audioBuffer ); 
                            });
                        };
                        //Load blob
                        fileReader.readAsArrayBuffer(myBlob);
                    }
                    convertBlobToAudioBuffer(blob);


                    var au = document.createElement('audio');
                    au.controls = true;
                    au.srcObject = null;
                    au.src = URL.createObjectURL(blob);
                    audioBlobsContainer.appendChild(au);
                    audioBlobsContainer.appendChild(document.createElement('hr'));
                }
            });

            recorder.startRecording();

            dateStarted = new Date().getTime();

            (function looper() {
                if(!recorder) {
                    return;
                }

                document.querySelector('h3').innerHTML = 'Recording Duration: ' + calculateTimeDuration((new Date().getTime() - dateStarted) / 1000);

                setTimeout(looper, 1000);
            })();



            // release microphone on stopRecording
            recorder.microphone = microphone;

            document.getElementById('btn-stop-recording').disabled = false;
        });
    };

    document.getElementById('btn-stop-recording').onclick = function() {
        this.disabled = true;        
        recorder.stopRecording(stopRecordingCallback);
        is_ready_to_record = true;
        is_recording = false;
        is_recorded = true;
        document.getElementById('btn-start-recording').disabled = false;
    };

    // ------------------------------------------------------------

    // below two methods are copied from dev/StereoAudioRecorder.js
    // just to explain how to process RAW PCM data

    // ------------------------------------------------------------

    function mergeLeftRightBuffers(config, callback) {
        function mergeAudioBuffers(config, cb) {
            var numberOfAudioChannels = config.numberOfAudioChannels;

            // todo: "slice(0)" --- is it causes loop? Should be removed?
            var leftBuffers = config.leftBuffers.slice(0);
            var rightBuffers = config.rightBuffers.slice(0);
            var sampleRate = config.sampleRate;
            var internalInterleavedLength = config.internalInterleavedLength;
            var desiredSampRate = config.desiredSampRate;

            if (numberOfAudioChannels === 2) {
                leftBuffers = mergeBuffers(leftBuffers, internalInterleavedLength);
                rightBuffers = mergeBuffers(rightBuffers, internalInterleavedLength);
                if (desiredSampRate) {
                    leftBuffers = interpolateArray(leftBuffers, desiredSampRate, sampleRate);
                    rightBuffers = interpolateArray(rightBuffers, desiredSampRate, sampleRate);
                }
            }

            if (numberOfAudioChannels === 1) {
                leftBuffers = mergeBuffers(leftBuffers, internalInterleavedLength);
                if (desiredSampRate) {
                    leftBuffers = interpolateArray(leftBuffers, desiredSampRate, sampleRate);
                }
            }

            // set sample rate as desired sample rate
            if (desiredSampRate) {
                sampleRate = desiredSampRate;
            }

            // for changing the sampling rate, reference:
            // http://stackoverflow.com/a/28977136/552182
            function interpolateArray(data, newSampleRate, oldSampleRate) {
                var fitCount = Math.round(data.length * (newSampleRate / oldSampleRate));
                //var newData = new Array();
                var newData = [];
                //var springFactor = new Number((data.length - 1) / (fitCount - 1));
                var springFactor = Number((data.length - 1) / (fitCount - 1));
                newData[0] = data[0]; // for new allocation
                for (var i = 1; i < fitCount - 1; i++) {
                    var tmp = i * springFactor;
                    //var before = new Number(Math.floor(tmp)).toFixed();
                    //var after = new Number(Math.ceil(tmp)).toFixed();
                    var before = Number(Math.floor(tmp)).toFixed();
                    var after = Number(Math.ceil(tmp)).toFixed();
                    var atPoint = tmp - before;
                    newData[i] = linearInterpolate(data[before], data[after], atPoint);
                }
                newData[fitCount - 1] = data[data.length - 1]; // for new allocation
                return newData;
            }

            function linearInterpolate(before, after, atPoint) {
                return before + (after - before) * atPoint;
            }

            function mergeBuffers(channelBuffer, rLength) {
                var result = new Float64Array(rLength);
                var offset = 0;
                var lng = channelBuffer.length;

                for (var i = 0; i < lng; i++) {
                    var buffer = channelBuffer[i];
                    result.set(buffer, offset);
                    offset += buffer.length;
                }

                return result;
            }

            function interleave(leftChannel, rightChannel) {
                var length = leftChannel.length + rightChannel.length;

                var result = new Float64Array(length);

                var inputIndex = 0;

                for (var index = 0; index < length;) {
                    result[index++] = leftChannel[inputIndex];
                    result[index++] = rightChannel[inputIndex];
                    inputIndex++;
                }
                return result;
            }

            function writeUTFBytes(view, offset, string) {
                var lng = string.length;
                for (var i = 0; i < lng; i++) {
                    view.setUint8(offset + i, string.charCodeAt(i));
                }
            }

            // interleave both channels together
            var interleaved;

            if (numberOfAudioChannels === 2) {
                interleaved = interleave(leftBuffers, rightBuffers);
            }

            if (numberOfAudioChannels === 1) {
                interleaved = leftBuffers;
            }

            var interleavedLength = interleaved.length;

            // create wav file
            var resultingBufferLength = 44 + interleavedLength * 2;

            var buffer = new ArrayBuffer(resultingBufferLength);

            var view = new DataView(buffer);

            // RIFF chunk descriptor/identifier 
            writeUTFBytes(view, 0, 'RIFF');

            // RIFF chunk length
            view.setUint32(4, 44 + interleavedLength * 2, true);

            // RIFF type 
            writeUTFBytes(view, 8, 'WAVE');

            // format chunk identifier 
            // FMT sub-chunk
            writeUTFBytes(view, 12, 'fmt ');

            // format chunk length 
            view.setUint32(16, 16, true);

            // sample format (raw)
            view.setUint16(20, 1, true);

            // stereo (2 channels)
            view.setUint16(22, numberOfAudioChannels, true);

            // sample rate 
            view.setUint32(24, sampleRate, true);

            // byte rate (sample rate * block align)
            view.setUint32(28, sampleRate * 2, true);

            // block align (channel count * bytes per sample) 
            view.setUint16(32, numberOfAudioChannels * 2, true);

            // bits per sample 
            view.setUint16(34, 16, true);

            // data sub-chunk
            // data chunk identifier 
            writeUTFBytes(view, 36, 'data');

            // data chunk length 
            view.setUint32(40, interleavedLength * 2, true);

            // write the PCM samples
            var lng = interleavedLength;
            var index = 44;
            var volume = 1;
            for (var i = 0; i < lng; i++) {
                view.setInt16(index, interleaved[i] * (0x7FFF * volume), true);
                index += 2;
            }

            if (cb) {
                return cb({
                    buffer: buffer,
                    view: view
                });
            }

            postMessage({
                buffer: buffer,
                view: view
            });
        }

        if (!isChrome) {
            // its Microsoft Edge
            mergeAudioBuffers(config, function(data) {
                callback(data.buffer, data.view);
            });
            return;
        }


        var webWorker = processInWebWorker(mergeAudioBuffers);

        webWorker.onmessage = function(event) {
            callback(event.data.buffer, event.data.view);

            // release memory
            URL.revokeObjectURL(webWorker.workerURL);
        };

        webWorker.postMessage(config);
    }

    function processInWebWorker(_function) {
    var workerURL = URL.createObjectURL(new Blob([_function.toString(),
        ';this.onmessage =  function (eee) {' + _function.name + '(eee.data);}'
    ], {
        type: 'application/javascript'
    }));

    var worker = new Worker(workerURL);
    worker.workerURL = workerURL;
    return worker;
}
</script>

<footer style="margin-top: 20px;"><small id="send-message"></small></footer>
<script src="https://www.webrtc-experiment.com/common.js"></script>
</body>
</html>